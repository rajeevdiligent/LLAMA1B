{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context9.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_94 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_94():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_94/\")\nasync def get_items(db: AsyncSession = Depends(get_db_94)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_134 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_134():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_134/\")\nasync def get_items(db: AsyncSession = Depends(get_db_134)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions39.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_179 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_179():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_179/\")\nasync def get_items(db: AsyncSession = Depends(get_db_179)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_15 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_15():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_15/\")\nasync def get_items(db: AsyncSession = Depends(get_db_15)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_190 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_190():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_190/\")\nasync def get_items(db: AsyncSession = Depends(get_db_190)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context11.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_147 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_147():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_147/\")\nasync def get_items(db: AsyncSession = Depends(get_db_147)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions23.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement async CRUD operations for User model using AsyncSession. Include create, read, update, delete.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite+aiosqlite:///./users.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    email: Mapped[str]\n\nclass UserCreate(BaseModel):\n    name: str\n    email: str\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/users\")\nasync def create_user(user: UserCreate, db: AsyncSession = Depends(get_db)):\n    new_user = User(name=user.name, email=user.email)\n    db.add(new_user)\n    await db.commit()\n    await db.refresh(new_user)\n    return {\"id\": new_user.id, \"name\": new_user.name, \"email\": new_user.email}\n\n@app.get(\"/users/{user_id}\")\nasync def get_user(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\"id\": user.id, \"name\": user.name, \"email\": user.email}\n\n@app.delete(\"/users/{user_id}\")\nasync def delete_user(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(select(User).where(User.id == user_id))\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    await db.delete(user)\n    await db.commit()\n    return {\"message\": \"User deleted\"}\n", "category": "async_sqlalchemy", "subcategory": "crud", "difficulty": "medium"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app2.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context15.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_139 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_139():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_139/\")\nasync def get_items(db: AsyncSession = Depends(get_db_139)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_183 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_183():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_183/\")\nasync def get_items(db: AsyncSession = Depends(get_db_183)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_38 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_38():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_38/\")\nasync def get_items(db: AsyncSession = Depends(get_db_38)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_5 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_5():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_5/\")\nasync def get_items(db: AsyncSession = Depends(get_db_5)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_165 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_165():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_165/\")\nasync def get_items(db: AsyncSession = Depends(get_db_165)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_18 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_18():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_18/\")\nasync def get_items(db: AsyncSession = Depends(get_db_18)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_149 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_149():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_149/\")\nasync def get_items(db: AsyncSession = Depends(get_db_149)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions22.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions28.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_91 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_91():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_91/\")\nasync def get_items(db: AsyncSession = Depends(get_db_91)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_8 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_8():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_8/\")\nasync def get_items(db: AsyncSession = Depends(get_db_8)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions34.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app16.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_70 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_70():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_70/\")\nasync def get_items(db: AsyncSession = Depends(get_db_70)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions9.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_142 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_142():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_142/\")\nasync def get_items(db: AsyncSession = Depends(get_db_142)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_157 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_157():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_157/\")\nasync def get_items(db: AsyncSession = Depends(get_db_157)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions31.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_113 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_113():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_113/\")\nasync def get_items(db: AsyncSession = Depends(get_db_113)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_51 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_51():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_51/\")\nasync def get_items(db: AsyncSession = Depends(get_db_51)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_46 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_46():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_46/\")\nasync def get_items(db: AsyncSession = Depends(get_db_46)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app1.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_174 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_174():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_174/\")\nasync def get_items(db: AsyncSession = Depends(get_db_174)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_77 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_77():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_77/\")\nasync def get_items(db: AsyncSession = Depends(get_db_77)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app35.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_61 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_61():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_61/\")\nasync def get_items(db: AsyncSession = Depends(get_db_61)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions2.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_152 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_152():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_152/\")\nasync def get_items(db: AsyncSession = Depends(get_db_152)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app20.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions33.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context21.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_154 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_154():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_154/\")\nasync def get_items(db: AsyncSession = Depends(get_db_154)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_10 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_10():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_10/\")\nasync def get_items(db: AsyncSession = Depends(get_db_10)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_102 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_102():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_102/\")\nasync def get_items(db: AsyncSession = Depends(get_db_102)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_50 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_50():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_50/\")\nasync def get_items(db: AsyncSession = Depends(get_db_50)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app29.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_197 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_197():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_197/\")\nasync def get_items(db: AsyncSession = Depends(get_db_197)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app19.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_48 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_48():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_48/\")\nasync def get_items(db: AsyncSession = Depends(get_db_48)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_45 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_45():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_45/\")\nasync def get_items(db: AsyncSession = Depends(get_db_45)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_163 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_163():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_163/\")\nasync def get_items(db: AsyncSession = Depends(get_db_163)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app39.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context0.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_57 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_57():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_57/\")\nasync def get_items(db: AsyncSession = Depends(get_db_57)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context28.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_130 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_130():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_130/\")\nasync def get_items(db: AsyncSession = Depends(get_db_130)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_66 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_66():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_66/\")\nasync def get_items(db: AsyncSession = Depends(get_db_66)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context22.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_72 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_72():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_72/\")\nasync def get_items(db: AsyncSession = Depends(get_db_72)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_4 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_4():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_4/\")\nasync def get_items(db: AsyncSession = Depends(get_db_4)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app11.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_74 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_74():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_74/\")\nasync def get_items(db: AsyncSession = Depends(get_db_74)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_167 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_167():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_167/\")\nasync def get_items(db: AsyncSession = Depends(get_db_167)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_96 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_96():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_96/\")\nasync def get_items(db: AsyncSession = Depends(get_db_96)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_126 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_126():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_126/\")\nasync def get_items(db: AsyncSession = Depends(get_db_126)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_22 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_22():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_22/\")\nasync def get_items(db: AsyncSession = Depends(get_db_22)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions0.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_124 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_124():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_124/\")\nasync def get_items(db: AsyncSession = Depends(get_db_124)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_162 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_162():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_162/\")\nasync def get_items(db: AsyncSession = Depends(get_db_162)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context26.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions16.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_54 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_54():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_54/\")\nasync def get_items(db: AsyncSession = Depends(get_db_54)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_36 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_36():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_36/\")\nasync def get_items(db: AsyncSession = Depends(get_db_36)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_47 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_47():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_47/\")\nasync def get_items(db: AsyncSession = Depends(get_db_47)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_92 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_92():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_92/\")\nasync def get_items(db: AsyncSession = Depends(get_db_92)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context16.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_155 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_155():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_155/\")\nasync def get_items(db: AsyncSession = Depends(get_db_155)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context2.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_68 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_68():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_68/\")\nasync def get_items(db: AsyncSession = Depends(get_db_68)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions14.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_125 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_125():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_125/\")\nasync def get_items(db: AsyncSession = Depends(get_db_125)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app8.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_172 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_172():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_172/\")\nasync def get_items(db: AsyncSession = Depends(get_db_172)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_31 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_31():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_31/\")\nasync def get_items(db: AsyncSession = Depends(get_db_31)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_103 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_103():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_103/\")\nasync def get_items(db: AsyncSession = Depends(get_db_103)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context18.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context29.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app24.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_143 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_143():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_143/\")\nasync def get_items(db: AsyncSession = Depends(get_db_143)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_187 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_187():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_187/\")\nasync def get_items(db: AsyncSession = Depends(get_db_187)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_9 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_9():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_9/\")\nasync def get_items(db: AsyncSession = Depends(get_db_9)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_65 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_65():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_65/\")\nasync def get_items(db: AsyncSession = Depends(get_db_65)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context10.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_82 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_82():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_82/\")\nasync def get_items(db: AsyncSession = Depends(get_db_82)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_150 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_150():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_150/\")\nasync def get_items(db: AsyncSession = Depends(get_db_150)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_169 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_169():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_169/\")\nasync def get_items(db: AsyncSession = Depends(get_db_169)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_62 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_62():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_62/\")\nasync def get_items(db: AsyncSession = Depends(get_db_62)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app10.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app32.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_136 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_136():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_136/\")\nasync def get_items(db: AsyncSession = Depends(get_db_136)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions8.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions29.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context13.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions36.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app33.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app36.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_34 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_34():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_34/\")\nasync def get_items(db: AsyncSession = Depends(get_db_34)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_171 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_171():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_171/\")\nasync def get_items(db: AsyncSession = Depends(get_db_171)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_19 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_19():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_19/\")\nasync def get_items(db: AsyncSession = Depends(get_db_19)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_90 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_90():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_90/\")\nasync def get_items(db: AsyncSession = Depends(get_db_90)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_37 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_37():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_37/\")\nasync def get_items(db: AsyncSession = Depends(get_db_37)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_64 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_64():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_64/\")\nasync def get_items(db: AsyncSession = Depends(get_db_64)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_12 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_12():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_12/\")\nasync def get_items(db: AsyncSession = Depends(get_db_12)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context25.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_60 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_60():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_60/\")\nasync def get_items(db: AsyncSession = Depends(get_db_60)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_138 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_138():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_138/\")\nasync def get_items(db: AsyncSession = Depends(get_db_138)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app37.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app23.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_145 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_145():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_145/\")\nasync def get_items(db: AsyncSession = Depends(get_db_145)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_55 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_55():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_55/\")\nasync def get_items(db: AsyncSession = Depends(get_db_55)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_79 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_79():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_79/\")\nasync def get_items(db: AsyncSession = Depends(get_db_79)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app17.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_106 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_106():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_106/\")\nasync def get_items(db: AsyncSession = Depends(get_db_106)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_140 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_140():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_140/\")\nasync def get_items(db: AsyncSession = Depends(get_db_140)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app22.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_3 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_3():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_3/\")\nasync def get_items(db: AsyncSession = Depends(get_db_3)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_2 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_2():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_2/\")\nasync def get_items(db: AsyncSession = Depends(get_db_2)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app5.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions37.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_81 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_81():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_81/\")\nasync def get_items(db: AsyncSession = Depends(get_db_81)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions30.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_13 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_13():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_13/\")\nasync def get_items(db: AsyncSession = Depends(get_db_13)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_26 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_26():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_26/\")\nasync def get_items(db: AsyncSession = Depends(get_db_26)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_168 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_168():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_168/\")\nasync def get_items(db: AsyncSession = Depends(get_db_168)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app28.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_32 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_32():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_32/\")\nasync def get_items(db: AsyncSession = Depends(get_db_32)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_93 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_93():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_93/\")\nasync def get_items(db: AsyncSession = Depends(get_db_93)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_189 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_189():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_189/\")\nasync def get_items(db: AsyncSession = Depends(get_db_189)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app12.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Use async context manager pattern for database operations with proper cleanup.", "input": "", "output": "from fastapi import FastAPI\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom contextlib import asynccontextmanager\n\nDATABASE_URL = \"sqlite+aiosqlite:///./context20.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Item(Base):\n    __tablename__ = \"items\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n\n@asynccontextmanager\nasync def get_session():\n    async with async_session_maker() as session:\n        try:\n            yield session\n            await session.commit()\n        except Exception:\n            await session.rollback()\n            raise\n        finally:\n            await session.close()\n\napp = FastAPI()\n\n@app.post(\"/items\")\nasync def create_item(name: str):\n    async with get_session() as session:\n        item = Item(name=name)\n        session.add(item)\n        return {\"message\": \"Item created\", \"name\": name}\n", "category": "async_sqlalchemy", "subcategory": "context_managers", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_108 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_108():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_108/\")\nasync def get_items(db: AsyncSession = Depends(get_db_108)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app34.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_87 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_87():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_87/\")\nasync def get_items(db: AsyncSession = Depends(get_db_87)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_100 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_100():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_100/\")\nasync def get_items(db: AsyncSession = Depends(get_db_100)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions19.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions13.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_88 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_88():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_88/\")\nasync def get_items(db: AsyncSession = Depends(get_db_88)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_141 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_141():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_141/\")\nasync def get_items(db: AsyncSession = Depends(get_db_141)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_160 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_160():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_160/\")\nasync def get_items(db: AsyncSession = Depends(get_db_160)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app26.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_192 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_192():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_192/\")\nasync def get_items(db: AsyncSession = Depends(get_db_192)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_111 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_111():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_111/\")\nasync def get_items(db: AsyncSession = Depends(get_db_111)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app18.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_178 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_178():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_178/\")\nasync def get_items(db: AsyncSession = Depends(get_db_178)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_25 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_25():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_25/\")\nasync def get_items(db: AsyncSession = Depends(get_db_25)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_188 and pattern_8", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_188():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_188/\")\nasync def get_items(db: AsyncSession = Depends(get_db_188)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_184 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_184():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_184/\")\nasync def get_items(db: AsyncSession = Depends(get_db_184)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_105 and pattern_5", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_105():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_105/\")\nasync def get_items(db: AsyncSession = Depends(get_db_105)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions4.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions6.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_52 and pattern_2", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_52():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_52/\")\nasync def get_items(db: AsyncSession = Depends(get_db_52)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_137 and pattern_7", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_137():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_137/\")\nasync def get_items(db: AsyncSession = Depends(get_db_137)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_186 and pattern_6", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_186():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_186/\")\nasync def get_items(db: AsyncSession = Depends(get_db_186)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_170 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_170():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_170/\")\nasync def get_items(db: AsyncSession = Depends(get_db_170)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_144 and pattern_4", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_144():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_144/\")\nasync def get_items(db: AsyncSession = Depends(get_db_144)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_159 and pattern_9", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_159():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_159/\")\nasync def get_items(db: AsyncSession = Depends(get_db_159)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_11 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_11():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_11/\")\nasync def get_items(db: AsyncSession = Depends(get_db_11)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement async transaction with rollback handling in FastAPI using async with statement.", "input": "", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\nfrom sqlalchemy import select\n\nDATABASE_URL = \"sqlite+aiosqlite:///./transactions18.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Account(Base):\n    __tablename__ = \"accounts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    balance: Mapped[float]\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.post(\"/transfer\")\nasync def transfer_money(from_id: int, to_id: int, amount: float, db: AsyncSession = Depends(get_db)):\n    try:\n        async with db.begin():\n            # Get accounts\n            result1 = await db.execute(select(Account).where(Account.id == from_id))\n            from_account = result1.scalar_one_or_none()\n            \n            result2 = await db.execute(select(Account).where(Account.id == to_id))\n            to_account = result2.scalar_one_or_none()\n            \n            if not from_account or not to_account:\n                raise HTTPException(status_code=404, detail=\"Account not found\")\n            \n            if from_account.balance < amount:\n                raise HTTPException(status_code=400, detail=\"Insufficient funds\")\n            \n            # Transfer\n            from_account.balance -= amount\n            to_account.balance += amount\n            \n            await db.commit()\n            return {\"message\": \"Transfer successful\", \"amount\": amount}\n    except Exception as e:\n        await db.rollback()\n        raise HTTPException(status_code=500, detail=f\"Transfer failed: {str(e)}\")\n", "category": "async_sqlalchemy", "subcategory": "transactions", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_133 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_133():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_133/\")\nasync def get_items(db: AsyncSession = Depends(get_db_133)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_121 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_121():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_121/\")\nasync def get_items(db: AsyncSession = Depends(get_db_121)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app6.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_41 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_41():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_41/\")\nasync def get_items(db: AsyncSession = Depends(get_db_41)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_23 and pattern_3", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_23():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_23/\")\nasync def get_items(db: AsyncSession = Depends(get_db_23)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app27.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_191 and pattern_1", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_191():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_191/\")\nasync def get_items(db: AsyncSession = Depends(get_db_191)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Create async SQLAlchemy endpoint with relationship loading using selectinload or joinedload.", "input": "", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column, relationship, selectinload\nfrom sqlalchemy import select, ForeignKey\nfrom typing import List\n\nDATABASE_URL = \"sqlite+aiosqlite:///./app9.db\"\nengine = create_async_engine(DATABASE_URL)\nasync_session_maker = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str]\n    posts: Mapped[List[\"Post\"]] = relationship(back_populates=\"user\")\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    title: Mapped[str]\n    user_id: Mapped[int] = mapped_column(ForeignKey(\"users.id\"))\n    user: Mapped[\"User\"] = relationship(back_populates=\"posts\")\n\nasync def get_db():\n    async with async_session_maker() as session:\n        yield session\n\napp = FastAPI()\n\n@app.get(\"/users/{user_id}/with-posts\")\nasync def get_user_with_posts(user_id: int, db: AsyncSession = Depends(get_db)):\n    result = await db.execute(\n        select(User).where(User.id == user_id).options(selectinload(User.posts))\n    )\n    user = result.scalar_one_or_none()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return {\n        \"id\": user.id,\n        \"name\": user.name,\n        \"posts\": [{{id\": p.id, \"title\": p.title}} for p in user.posts]\n    }\n", "category": "async_sqlalchemy", "subcategory": "relationships", "difficulty": "hard"}
{"instruction": "Implement FastAPI async sqlalchemy with feature_110 and pattern_0", "output": "from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\nfrom sqlalchemy import select\nfrom fastapi import Depends\n\nasync def get_db_110():\n    async with AsyncSessionLocal() as session:\n        try:\n            yield session\n            await session.commit()\n        except:\n            await session.rollback()\n            raise\n\n@app.get(\"/items_110/\")\nasync def get_items(db: AsyncSession = Depends(get_db_110)):\n    query = select(Item).where(Item.active == True)\n    result = await db.execute(query)\n    return result.scalars().all()", "category": "async_sqlalchemy"}
{"instruction": "Implement FastAPI background tasks with feature_121 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_121(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_121/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_121, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_1 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_1(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_1/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_1, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_44 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_44(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_44/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_44, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_29 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_29(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_29/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_29, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_46 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_46(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_46/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_46, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_99 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_99(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_99/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_99, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_98 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_98(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_98/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_98, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_72 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_72(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_72/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_72, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_41 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_41(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_41/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_41, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_97 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_97(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_97/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_97, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_122 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_122(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_122/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_122, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_139 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_139(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_139/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_139, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_28 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_28(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_28/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_28, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_118 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_118(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_118/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_118, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_148 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_148(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_148/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_148, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_103 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_103(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_103/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_103, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_126 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_126(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_126/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_126, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_51 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_51(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_51/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_51, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_124 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_124(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_124/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_124, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_20 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_20(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_20/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_20, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_84 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_84(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_84/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_84, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_3 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_3(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_3/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_3, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_43 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_43(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_43/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_43, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_4 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_4(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_4/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_4, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_35 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_35(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_35/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_35, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_2 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_2(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_2/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_2, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_14 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_14(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_14/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_14, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_59 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_59(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_59/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_59, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_80 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_80(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_80/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_80, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_76 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_76(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_76/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_76, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_108 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_108(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_108/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_108, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_134 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_134(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_134/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_134, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_145 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_145(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_145/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_145, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_65 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_65(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_65/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_65, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_83 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_83(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_83/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_83, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_100 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_100(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_100/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_100, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_9 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_9(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_9/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_9, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_137 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_137(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_137/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_137, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_8 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_8(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_8/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_8, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_11 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_11(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_11/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_11, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_37 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_37(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_37/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_37, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_78 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_78(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_78/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_78, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_60 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_60(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_60/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_60, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_144 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_144(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_144/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_144, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_120 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_120(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_120/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_120, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_123 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_123(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_123/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_123, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_77 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_77(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_77/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_77, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_12 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_12(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_12/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_12, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_63 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_63(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_63/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_63, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_104 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_104(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_104/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_104, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI application with background tasks. Include email sending, file processing, and cleanup operations that run asynchronously.", "input": "", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom pydantic import BaseModel, EmailStr\nimport time\nfrom typing import List\n\napp = FastAPI()\n\n# Simulated task functions\ndef send_email(email: str, message: str):\n    time.sleep(2)  # Simulate email sending\n    print(f\"Email sent to {email}: {message}\")\n\ndef process_file(filename: str):\n    time.sleep(3)  # Simulate file processing\n    print(f\"File processed: {filename}\")\n\ndef cleanup_old_files():\n    time.sleep(1)  # Simulate cleanup\n    print(\"Old files cleaned up\")\n\nclass EmailRequest(BaseModel):\n    email: EmailStr\n    subject: str\n    message: str\n\nclass FileUpload(BaseModel):\n    filename: str\n    content: str\n\n@app.post(\"/send-email\")\ndef send_email_endpoint(email_data: EmailRequest, background_tasks: BackgroundTasks):\n    background_tasks.add_task(send_email, email_data.email, email_data.message)\n    return {\"message\": \"Email will be sent in the background\"}\n\n@app.post(\"/upload\")\ndef upload_file(file: FileUpload, background_tasks: BackgroundTasks):\n    # Save file immediately\n    saved_path = f\"/uploads/{file.filename}\"\n    \n    # Process in background\n    background_tasks.add_task(process_file, file.filename)\n    background_tasks.add_task(cleanup_old_files)\n    \n    return {\"message\": \"File uploaded\", \"path\": saved_path}\n\n@app.post(\"/batch-emails\")\ndef send_batch_emails(emails: List[EmailRequest], background_tasks: BackgroundTasks):\n    for email_data in emails:\n        background_tasks.add_task(send_email, email_data.email, email_data.message)\n    return {\"message\": f\"{len(emails)} emails queued for sending\"}\n\n@app.get(\"/health\")\ndef health_check():\n    return {\"status\": \"healthy\"}", "source_phase": "phase2_advanced", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_114 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_114(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_114/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_114, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_88 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_88(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_88/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_88, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_36 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_36(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_36/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_36, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_141 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_141(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_141/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_141, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_33 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_33(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_33/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_33, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_105 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_105(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_105/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_105, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_31 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_31(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_31/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_31, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_47 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_47(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_47/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_47, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_130 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_130(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_130/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_130, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_75 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_75(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_75/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_75, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_129 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_129(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_129/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_129, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_18 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_18(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_18/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_18, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_132 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_132(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_132/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_132, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_64 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_64(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_64/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_64, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_109 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_109(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_109/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_109, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_45 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_45(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_45/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_45, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_50 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_50(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_50/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_50, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_102 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_102(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_102/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_102, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_53 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_53(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_53/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_53, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_110 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_110(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_110/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_110, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_127 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_127(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_127/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_127, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_94 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_94(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_94/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_94, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_32 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_32(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_32/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_32, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_131 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_131(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_131/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_131, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_81 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_81(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_81/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_81, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_112 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_112(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_112/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_112, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_62 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_62(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_62/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_62, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_133 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_133(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_133/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_133, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_125 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_125(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_125/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_125, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_111 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_111(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_111/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_111, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_71 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_71(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_71/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_71, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_119 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_119(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_119/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_119, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_26 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_26(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_26/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_26, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_15 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_15(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_15/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_15, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_143 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_143(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_143/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_143, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_101 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_101(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_101/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_101, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_79 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_79(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_79/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_79, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_13 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_13(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_13/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_13, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_82 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_82(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_82/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_82, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_68 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_68(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_68/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_68, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_117 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_117(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_117/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_117, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_147 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_147(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_147/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_147, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_135 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_135(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_135/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_135, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_42 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_42(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_42/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_42, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_17 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_17(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_17/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_17, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_67 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_67(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_67/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_67, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_52 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_52(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_52/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_52, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_89 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_89(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_89/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_89, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_93 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_93(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_93/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_93, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_40 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_40(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_40/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_40, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_92 and pattern_2", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_92(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_92/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_92, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_115 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_115(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_115/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_115, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_24 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_24(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_24/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_24, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement background task for data processing after user upload.", "output": "from fastapi import BackgroundTasks, UploadFile, File\nimport pandas as pd\n\ndef process_csv_file(file_path: str, user_id: int):\n    df = pd.read_csv(file_path)\n    # Process data\n    results = df.describe()\n    # Save results to database\n    save_processing_results(user_id, results)\n    # Clean up temp file\n    os.remove(file_path)\n\n@app.post(\"/upload-data/\")\nasync def upload_data(\n    file: UploadFile = File(...),\n    background_tasks: BackgroundTasks = None\n):\n    # Save file temporarily\n    file_path = f\"/tmp/{file.filename}\"\n    with open(file_path, \"wb\") as buffer:\n        buffer.write(await file.read())\n    \n    # Process in background\n    background_tasks.add_task(process_csv_file, file_path, current_user.id)\n    \n    return {\"message\": \"File uploaded, processing started\"}", "category": "background_tasks", "subcategory": "data_processing", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_73 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_73(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_73/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_73, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_57 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_57(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_57/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_57, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_16 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_16(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_16/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_16, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_48 and pattern_8", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_48(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_48/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_48, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_146 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_146(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_146/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_146, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_91 and pattern_1", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_91(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_91/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_91, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_74 and pattern_4", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_74(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_74/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_74, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_140 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_140(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_140/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_140, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_19 and pattern_9", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_19(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_19/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_19, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_95 and pattern_5", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_95(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_95/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_95, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_30 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_30(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_30/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_30, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_136 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_136(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_136/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_136, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_116 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_116(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_116/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_116, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_10 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_10(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_10/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_10, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_66 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_66(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_66/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_66, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI background tasks with feature_87 and pattern_7", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_87(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_87/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_87, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_90 and pattern_0", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_90(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_90/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_90, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_23 and pattern_3", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_23(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_23/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_23, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Implement FastAPI background tasks with feature_96 and pattern_6", "output": "from fastapi import BackgroundTasks\nimport logging\n\ndef send_email_96(email: str, message: str):\n    logging.info(f\"Sending email to {email}: {message}\")\n    # Email sending logic here\n\n@app.post(\"/notify_96/\")\nasync def send_notification(\n    email: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email_96, email, \"Hello!\")\n    return {\"message\": \"Email will be sent in background\"}", "category": "background_tasks"}
{"instruction": "Create a FastAPI endpoint that sends email notifications in the background.", "output": "from fastapi import FastAPI, BackgroundTasks\nfrom fastapi.responses import JSONResponse\n\ndef send_email(email: str, message: str):\n    # Simulate email sending\n    import time\n    time.sleep(2)\n    print(f\"Email sent to {email}: {message}\")\n\n@app.post(\"/send-notification/\")\nasync def send_notification(\n    email: str,\n    message: str,\n    background_tasks: BackgroundTasks\n):\n    background_tasks.add_task(send_email, email, message)\n    return JSONResponse(\n        content={\"message\": \"Notification queued\"},\n        status_code=202\n    )", "category": "background_tasks", "subcategory": "email", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to create a new user with username, email, password. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String)\nemail = Column(String)\npassword = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass UserCreate(BaseModel):\n    username: str\n    email: str\n    password: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/users/\")\ndef create_user(user: UserCreate, db: Session = Depends(get_db)):\n    db_user = User(**user.dict())\n    db.add(db_user)\n    db.commit()\n    db.refresh(db_user)\n    return db_user\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a user by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n        username = Column(String)\n    email = Column(String)\n    password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass UserUpdate(BaseModel):\n    username: str\n    email: str\n    password: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/users/{item_id}\")\ndef update_user(item_id: int, user_update: UserUpdate, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.id == item_id).first()\n    if not db_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    for key, value in user_update.dict().items():\n        setattr(db_user, key, value)\n    \n    db.commit()\n    db.refresh(db_user)\n    return db_user\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a user by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n        username = Column(String)\n    email = Column(String)\n    password = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/users/{item_id}\")\ndef delete_user(item_id: int, db: Session = Depends(get_db)):\n    db_user = db.query(User).filter(User.id == item_id).first()\n    if not db_user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    db.delete(db_user)\n    db.commit()\n    return {\"message\": \"User deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new product with name, description, price. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\ndescription = Column(String)\nprice = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductCreate(BaseModel):\n    name: str\n    description: str\n    price: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/products/\")\ndef create_product(product: ProductCreate, db: Session = Depends(get_db)):\n    db_product = Product(**product.dict())\n    db.add(db_product)\n    db.commit()\n    db.refresh(db_product)\n    return db_product\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a product by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    description = Column(String)\n    price = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductUpdate(BaseModel):\n    name: str\n    description: str\n    price: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/products/{item_id}\")\ndef update_product(item_id: int, product_update: ProductUpdate, db: Session = Depends(get_db)):\n    db_product = db.query(Product).filter(Product.id == item_id).first()\n    if not db_product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    for key, value in product_update.dict().items():\n        setattr(db_product, key, value)\n    \n    db.commit()\n    db.refresh(db_product)\n    return db_product\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a product by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    description = Column(String)\n    price = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/products/{item_id}\")\ndef delete_product(item_id: int, db: Session = Depends(get_db)):\n    db_product = db.query(Product).filter(Product.id == item_id).first()\n    if not db_product:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    db.delete(db_product)\n    db.commit()\n    return {\"message\": \"Product deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new order with customer_id, total_amount, status. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String)\ntotal_amount = Column(String)\nstatus = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass OrderCreate(BaseModel):\n    customer_id: str\n    total_amount: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/orders/\")\ndef create_order(order: OrderCreate, db: Session = Depends(get_db)):\n    db_order = Order(**order.dict())\n    db.add(db_order)\n    db.commit()\n    db.refresh(db_order)\n    return db_order\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a order by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n        customer_id = Column(String)\n    total_amount = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass OrderUpdate(BaseModel):\n    customer_id: str\n    total_amount: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/orders/{item_id}\")\ndef update_order(item_id: int, order_update: OrderUpdate, db: Session = Depends(get_db)):\n    db_order = db.query(Order).filter(Order.id == item_id).first()\n    if not db_order:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    for key, value in order_update.dict().items():\n        setattr(db_order, key, value)\n    \n    db.commit()\n    db.refresh(db_order)\n    return db_order\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a order by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n        customer_id = Column(String)\n    total_amount = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/orders/{item_id}\")\ndef delete_order(item_id: int, db: Session = Depends(get_db)):\n    db_order = db.query(Order).filter(Order.id == item_id).first()\n    if not db_order:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    db.delete(db_order)\n    db.commit()\n    return {\"message\": \"Order deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new post with title, content, author_id. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String)\ncontent = Column(String)\nauthor_id = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass PostCreate(BaseModel):\n    title: str\n    content: str\n    author_id: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/posts/\")\ndef create_post(post: PostCreate, db: Session = Depends(get_db)):\n    db_post = Post(**post.dict())\n    db.add(db_post)\n    db.commit()\n    db.refresh(db_post)\n    return db_post\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a post by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True, index=True)\n        title = Column(String)\n    content = Column(String)\n    author_id = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass PostUpdate(BaseModel):\n    title: str\n    content: str\n    author_id: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/posts/{item_id}\")\ndef update_post(item_id: int, post_update: PostUpdate, db: Session = Depends(get_db)):\n    db_post = db.query(Post).filter(Post.id == item_id).first()\n    if not db_post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    \n    for key, value in post_update.dict().items():\n        setattr(db_post, key, value)\n    \n    db.commit()\n    db.refresh(db_post)\n    return db_post\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a post by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True, index=True)\n        title = Column(String)\n    content = Column(String)\n    author_id = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/posts/{item_id}\")\ndef delete_post(item_id: int, db: Session = Depends(get_db)):\n    db_post = db.query(Post).filter(Post.id == item_id).first()\n    if not db_post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    \n    db.delete(db_post)\n    db.commit()\n    return {\"message\": \"Post deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new comment with post_id, user_id, content. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True, index=True)\n    post_id = Column(String)\nuser_id = Column(String)\ncontent = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass CommentCreate(BaseModel):\n    post_id: str\n    user_id: str\n    content: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/comments/\")\ndef create_comment(comment: CommentCreate, db: Session = Depends(get_db)):\n    db_comment = Comment(**comment.dict())\n    db.add(db_comment)\n    db.commit()\n    db.refresh(db_comment)\n    return db_comment\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a comment by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True, index=True)\n        post_id = Column(String)\n    user_id = Column(String)\n    content = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass CommentUpdate(BaseModel):\n    post_id: str\n    user_id: str\n    content: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/comments/{item_id}\")\ndef update_comment(item_id: int, comment_update: CommentUpdate, db: Session = Depends(get_db)):\n    db_comment = db.query(Comment).filter(Comment.id == item_id).first()\n    if not db_comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n    \n    for key, value in comment_update.dict().items():\n        setattr(db_comment, key, value)\n    \n    db.commit()\n    db.refresh(db_comment)\n    return db_comment\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a comment by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True, index=True)\n        post_id = Column(String)\n    user_id = Column(String)\n    content = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/comments/{item_id}\")\ndef delete_comment(item_id: int, db: Session = Depends(get_db)):\n    db_comment = db.query(Comment).filter(Comment.id == item_id).first()\n    if not db_comment:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n    \n    db.delete(db_comment)\n    db.commit()\n    return {\"message\": \"Comment deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new task with title, description, status. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String)\ndescription = Column(String)\nstatus = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass TaskCreate(BaseModel):\n    title: str\n    description: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/tasks/\")\ndef create_task(task: TaskCreate, db: Session = Depends(get_db)):\n    db_task = Task(**task.dict())\n    db.add(db_task)\n    db.commit()\n    db.refresh(db_task)\n    return db_task\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a task by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n        title = Column(String)\n    description = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass TaskUpdate(BaseModel):\n    title: str\n    description: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/tasks/{item_id}\")\ndef update_task(item_id: int, task_update: TaskUpdate, db: Session = Depends(get_db)):\n    db_task = db.query(Task).filter(Task.id == item_id).first()\n    if not db_task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    for key, value in task_update.dict().items():\n        setattr(db_task, key, value)\n    \n    db.commit()\n    db.refresh(db_task)\n    return db_task\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a task by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n        title = Column(String)\n    description = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/tasks/{item_id}\")\ndef delete_task(item_id: int, db: Session = Depends(get_db)):\n    db_task = db.query(Task).filter(Task.id == item_id).first()\n    if not db_task:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    db.delete(db_task)\n    db.commit()\n    return {\"message\": \"Task deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new customer with name, email, phone. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\nemail = Column(String)\nphone = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass CustomerCreate(BaseModel):\n    name: str\n    email: str\n    phone: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/customers/\")\ndef create_customer(customer: CustomerCreate, db: Session = Depends(get_db)):\n    db_customer = Customer(**customer.dict())\n    db.add(db_customer)\n    db.commit()\n    db.refresh(db_customer)\n    return db_customer\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a customer by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    email = Column(String)\n    phone = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass CustomerUpdate(BaseModel):\n    name: str\n    email: str\n    phone: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/customers/{item_id}\")\ndef update_customer(item_id: int, customer_update: CustomerUpdate, db: Session = Depends(get_db)):\n    db_customer = db.query(Customer).filter(Customer.id == item_id).first()\n    if not db_customer:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    for key, value in customer_update.dict().items():\n        setattr(db_customer, key, value)\n    \n    db.commit()\n    db.refresh(db_customer)\n    return db_customer\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a customer by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    email = Column(String)\n    phone = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/customers/{item_id}\")\ndef delete_customer(item_id: int, db: Session = Depends(get_db)):\n    db_customer = db.query(Customer).filter(Customer.id == item_id).first()\n    if not db_customer:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    db.delete(db_customer)\n    db.commit()\n    return {\"message\": \"Customer deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new invoice with customer_id, amount, status. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String)\namount = Column(String)\nstatus = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass InvoiceCreate(BaseModel):\n    customer_id: str\n    amount: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/invoices/\")\ndef create_invoice(invoice: InvoiceCreate, db: Session = Depends(get_db)):\n    db_invoice = Invoice(**invoice.dict())\n    db.add(db_invoice)\n    db.commit()\n    db.refresh(db_invoice)\n    return db_invoice\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a invoice by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n        customer_id = Column(String)\n    amount = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass InvoiceUpdate(BaseModel):\n    customer_id: str\n    amount: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/invoices/{item_id}\")\ndef update_invoice(item_id: int, invoice_update: InvoiceUpdate, db: Session = Depends(get_db)):\n    db_invoice = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not db_invoice:\n        raise HTTPException(status_code=404, detail=\"Invoice not found\")\n    \n    for key, value in invoice_update.dict().items():\n        setattr(db_invoice, key, value)\n    \n    db.commit()\n    db.refresh(db_invoice)\n    return db_invoice\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a invoice by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n        customer_id = Column(String)\n    amount = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/invoices/{item_id}\")\ndef delete_invoice(item_id: int, db: Session = Depends(get_db)):\n    db_invoice = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not db_invoice:\n        raise HTTPException(status_code=404, detail=\"Invoice not found\")\n    \n    db.delete(db_invoice)\n    db.commit()\n    return {\"message\": \"Invoice deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new employee with name, email, department. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\nemail = Column(String)\ndepartment = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass EmployeeCreate(BaseModel):\n    name: str\n    email: str\n    department: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/employees/\")\ndef create_employee(employee: EmployeeCreate, db: Session = Depends(get_db)):\n    db_employee = Employee(**employee.dict())\n    db.add(db_employee)\n    db.commit()\n    db.refresh(db_employee)\n    return db_employee\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a employee by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    email = Column(String)\n    department = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass EmployeeUpdate(BaseModel):\n    name: str\n    email: str\n    department: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/employees/{item_id}\")\ndef update_employee(item_id: int, employee_update: EmployeeUpdate, db: Session = Depends(get_db)):\n    db_employee = db.query(Employee).filter(Employee.id == item_id).first()\n    if not db_employee:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    \n    for key, value in employee_update.dict().items():\n        setattr(db_employee, key, value)\n    \n    db.commit()\n    db.refresh(db_employee)\n    return db_employee\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a employee by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    email = Column(String)\n    department = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/employees/{item_id}\")\ndef delete_employee(item_id: int, db: Session = Depends(get_db)):\n    db_employee = db.query(Employee).filter(Employee.id == item_id).first()\n    if not db_employee:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    \n    db.delete(db_employee)\n    db.commit()\n    return {\"message\": \"Employee deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a FastAPI endpoint to create a new project with name, description, status. Use SQLAlchemy for database operations.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String)\ndescription = Column(String)\nstatus = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProjectCreate(BaseModel):\n    name: str\n    description: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/projects/\")\ndef create_project(project: ProjectCreate, db: Session = Depends(get_db)):\n    db_project = Project(**project.dict())\n    db.add(db_project)\n    db.commit()\n    db.refresh(db_project)\n    return db_project\n", "category": "crud", "subcategory": "create"}
{"instruction": "Create a FastAPI endpoint to update a project by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    description = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProjectUpdate(BaseModel):\n    name: str\n    description: str\n    status: str\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.put(\"/projects/{item_id}\")\ndef update_project(item_id: int, project_update: ProjectUpdate, db: Session = Depends(get_db)):\n    db_project = db.query(Project).filter(Project.id == item_id).first()\n    if not db_project:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n    \n    for key, value in project_update.dict().items():\n        setattr(db_project, key, value)\n    \n    db.commit()\n    db.refresh(db_project)\n    return db_project\n", "category": "crud", "subcategory": "update"}
{"instruction": "Create a FastAPI endpoint to delete a project by ID using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True, index=True)\n        name = Column(String)\n    description = Column(String)\n    status = Column(String)\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.delete(\"/projects/{item_id}\")\ndef delete_project(item_id: int, db: Session = Depends(get_db)):\n    db_project = db.query(Project).filter(Project.id == item_id).first()\n    if not db_project:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n    \n    db.delete(db_project)\n    db.commit()\n    return {\"message\": \"Project deleted successfully\"}\n", "category": "crud", "subcategory": "delete"}
{"instruction": "Create a Product with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/products/\", status_code=201)\ndef create_product(item: ProductCreate, db: Session = Depends(get_db)):\n    db_item = Product(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Customer with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass CustomerUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/customers/{item_id}\")\ndef update_customer(item_id: int, updates: CustomerUpdate, db: Session = Depends(get_db)):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Invoice by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/invoices/{item_id}\", status_code=204)\ndef delete_invoice(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Invoice not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Invoice deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Project with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProjectCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/projects/\", status_code=201)\ndef create_project(item: ProjectCreate, db: Session = Depends(get_db)):\n    db_item = Project(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Employee with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass EmployeeUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/employees/{item_id}\")\ndef update_employee(item_id: int, updates: EmployeeUpdate, db: Session = Depends(get_db)):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Department by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/departments/{item_id}\", status_code=204)\ndef delete_department(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Department).filter(Department.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Department deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Review with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Review(Base):\n    __tablename__ = \"reviews\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ReviewCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/reviews/\", status_code=201)\ndef create_review(item: ReviewCreate, db: Session = Depends(get_db)):\n    db_item = Review(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Article with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass ArticleUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/articles/{item_id}\")\ndef update_article(item_id: int, updates: ArticleUpdate, db: Session = Depends(get_db)):\n    item = db.query(Article).filter(Article.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Article not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Event by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/events/{item_id}\", status_code=204)\ndef delete_event(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Event).filter(Event.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Event not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Event deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Payment with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Payment(Base):\n    __tablename__ = \"payments\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass PaymentCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/payments/\", status_code=201)\ndef create_payment(item: PaymentCreate, db: Session = Depends(get_db)):\n    db_item = Payment(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Message with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass MessageUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/messages/{item_id}\")\ndef update_message(item_id: int, updates: MessageUpdate, db: Session = Depends(get_db)):\n    item = db.query(Message).filter(Message.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Product by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/products/{item_id}\", status_code=204)\ndef delete_product(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Product deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Customer with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass CustomerCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/customers/\", status_code=201)\ndef create_customer(item: CustomerCreate, db: Session = Depends(get_db)):\n    db_item = Customer(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Ticket with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass TicketUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/tickets/{item_id}\")\ndef update_ticket(item_id: int, updates: TicketUpdate, db: Session = Depends(get_db)):\n    item = db.query(Ticket).filter(Ticket.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Ticket not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Project by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/projects/{item_id}\", status_code=204)\ndef delete_project(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Project).filter(Project.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Project deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Employee with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass EmployeeCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/employees/\", status_code=201)\ndef create_employee(item: EmployeeCreate, db: Session = Depends(get_db)):\n    db_item = Employee(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Category with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass CategoryUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/categorys/{item_id}\")\ndef update_category(item_id: int, updates: CategoryUpdate, db: Session = Depends(get_db)):\n    item = db.query(Category).filter(Category.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Review by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/reviews/{item_id}\", status_code=204)\ndef delete_review(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Review).filter(Review.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Review not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Review deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Article with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Article(Base):\n    __tablename__ = \"articles\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ArticleCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/articles/\", status_code=201)\ndef create_article(item: ArticleCreate, db: Session = Depends(get_db)):\n    db_item = Article(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Booking with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass BookingUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/bookings/{item_id}\")\ndef update_booking(item_id: int, updates: BookingUpdate, db: Session = Depends(get_db)):\n    item = db.query(Booking).filter(Booking.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Booking not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Payment by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/payments/{item_id}\", status_code=204)\ndef delete_payment(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Payment).filter(Payment.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Payment not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Payment deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Message with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Message(Base):\n    __tablename__ = \"messages\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass MessageCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/messages/\", status_code=201)\ndef create_message(item: MessageCreate, db: Session = Depends(get_db)):\n    db_item = Message(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Order with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass OrderUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/orders/{item_id}\")\ndef update_order(item_id: int, updates: OrderUpdate, db: Session = Depends(get_db)):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Customer by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/customers/{item_id}\", status_code=204)\ndef delete_customer(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Customer deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Ticket with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Ticket(Base):\n    __tablename__ = \"tickets\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass TicketCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/tickets/\", status_code=201)\ndef create_ticket(item: TicketCreate, db: Session = Depends(get_db)):\n    db_item = Ticket(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Task with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass TaskUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/tasks/{item_id}\")\ndef update_task(item_id: int, updates: TaskUpdate, db: Session = Depends(get_db)):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Employee by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/employees/{item_id}\", status_code=204)\ndef delete_employee(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Employee deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Category with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Category(Base):\n    __tablename__ = \"categorys\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass CategoryCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/categorys/\", status_code=201)\ndef create_category(item: CategoryCreate, db: Session = Depends(get_db)):\n    db_item = Category(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Comment with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass CommentUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/comments/{item_id}\")\ndef update_comment(item_id: int, updates: CommentUpdate, db: Session = Depends(get_db)):\n    item = db.query(Comment).filter(Comment.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Article by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/articles/{item_id}\", status_code=204)\ndef delete_article(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Article).filter(Article.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Article not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Article deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Booking with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Booking(Base):\n    __tablename__ = \"bookings\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass BookingCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/bookings/\", status_code=201)\ndef create_booking(item: BookingCreate, db: Session = Depends(get_db)):\n    db_item = Booking(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Notification with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass NotificationUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/notifications/{item_id}\")\ndef update_notification(item_id: int, updates: NotificationUpdate, db: Session = Depends(get_db)):\n    item = db.query(Notification).filter(Notification.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Notification not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Message by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/messages/{item_id}\", status_code=204)\ndef delete_message(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Message).filter(Message.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Message deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Order with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass OrderCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/orders/\", status_code=201)\ndef create_order(item: OrderCreate, db: Session = Depends(get_db)):\n    db_item = Order(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Invoice with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass InvoiceUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/invoices/{item_id}\")\ndef update_invoice(item_id: int, updates: InvoiceUpdate, db: Session = Depends(get_db)):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Invoice not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Ticket by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/tickets/{item_id}\", status_code=204)\ndef delete_ticket(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Ticket).filter(Ticket.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Ticket not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Ticket deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Task with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass TaskCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/tasks/\", status_code=201)\ndef create_task(item: TaskCreate, db: Session = Depends(get_db)):\n    db_item = Task(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Department with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass DepartmentUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/departments/{item_id}\")\ndef update_department(item_id: int, updates: DepartmentUpdate, db: Session = Depends(get_db)):\n    item = db.query(Department).filter(Department.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Category by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/categorys/{item_id}\", status_code=204)\ndef delete_category(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Category).filter(Category.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Category not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Category deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Comment with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Comment(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass CommentCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/comments/\", status_code=201)\ndef create_comment(item: CommentCreate, db: Session = Depends(get_db)):\n    db_item = Comment(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Event with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass EventUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/events/{item_id}\")\ndef update_event(item_id: int, updates: EventUpdate, db: Session = Depends(get_db)):\n    item = db.query(Event).filter(Event.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Event not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Booking by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/bookings/{item_id}\", status_code=204)\ndef delete_booking(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Booking).filter(Booking.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Booking not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Booking deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Notification with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Notification(Base):\n    __tablename__ = \"notifications\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass NotificationCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/notifications/\", status_code=201)\ndef create_notification(item: NotificationCreate, db: Session = Depends(get_db)):\n    db_item = Notification(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Product with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/products/{item_id}\")\ndef update_product(item_id: int, updates: ProductUpdate, db: Session = Depends(get_db)):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Order by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/orders/{item_id}\", status_code=204)\ndef delete_order(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Order deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Invoice with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass InvoiceCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/invoices/\", status_code=201)\ndef create_invoice(item: InvoiceCreate, db: Session = Depends(get_db)):\n    db_item = Invoice(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Project with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass ProjectUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/projects/{item_id}\")\ndef update_project(item_id: int, updates: ProjectUpdate, db: Session = Depends(get_db)):\n    item = db.query(Project).filter(Project.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Project not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Task by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/tasks/{item_id}\", status_code=204)\ndef delete_task(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Task not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Task deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Department with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Department(Base):\n    __tablename__ = \"departments\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass DepartmentCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/departments/\", status_code=201)\ndef create_department(item: DepartmentCreate, db: Session = Depends(get_db)):\n    db_item = Department(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Review with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass ReviewUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/reviews/{item_id}\")\ndef update_review(item_id: int, updates: ReviewUpdate, db: Session = Depends(get_db)):\n    item = db.query(Review).filter(Review.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Review not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Comment by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/comments/{item_id}\", status_code=204)\ndef delete_comment(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Comment).filter(Comment.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Comment not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Comment deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Event with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Event(Base):\n    __tablename__ = \"events\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass EventCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/events/\", status_code=201)\ndef create_event(item: EventCreate, db: Session = Depends(get_db)):\n    db_item = Event(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Payment with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass PaymentUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/payments/{item_id}\")\ndef update_payment(item_id: int, updates: PaymentUpdate, db: Session = Depends(get_db)):\n    item = db.query(Payment).filter(Payment.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Payment not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Notification by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/notifications/{item_id}\", status_code=204)\ndef delete_notification(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Notification).filter(Notification.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Notification not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Notification deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Product with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/products/\", status_code=201)\ndef create_product(item: ProductCreate, db: Session = Depends(get_db)):\n    db_item = Product(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Customer with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass CustomerUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/customers/{item_id}\")\ndef update_customer(item_id: int, updates: CustomerUpdate, db: Session = Depends(get_db)):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Invoice by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/invoices/{item_id}\", status_code=204)\ndef delete_invoice(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Invoice not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Invoice deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Project with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProjectCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/projects/\", status_code=201)\ndef create_project(item: ProjectCreate, db: Session = Depends(get_db)):\n    db_item = Project(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Employee with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass EmployeeUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/employees/{item_id}\")\ndef update_employee(item_id: int, updates: EmployeeUpdate, db: Session = Depends(get_db)):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Employee not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Department by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/departments/{item_id}\", status_code=204)\ndef delete_department(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Department).filter(Department.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Department not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Department deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Review with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Review(Base):\n    __tablename__ = \"reviews\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ReviewCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/reviews/\", status_code=201)\ndef create_review(item: ReviewCreate, db: Session = Depends(get_db)):\n    db_item = Review(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Article with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass ArticleUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/articles/{item_id}\")\ndef update_article(item_id: int, updates: ArticleUpdate, db: Session = Depends(get_db)):\n    item = db.query(Article).filter(Article.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Article not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Event by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/events/{item_id}\", status_code=204)\ndef delete_event(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Event).filter(Event.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Event not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Event deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a Payment with FastAPI and SQLAlchemy ORM with proper validation.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy import create_engine, Column, Integer, String, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\")\nSessionLocal = sessionmaker(bind=engine)\n\nclass Payment(Base):\n    __tablename__ = \"payments\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String(100), nullable=False, index=True)\n    description = Column(String(500))\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass PaymentCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/payments/\", status_code=201)\ndef create_payment(item: PaymentCreate, db: Session = Depends(get_db)):\n    db_item = Payment(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Update an existing Message with partial updates using FastAPI and SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel\nfrom typing import Optional\n\nclass MessageUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/messages/{item_id}\")\ndef update_message(item_id: int, updates: MessageUpdate, db: Session = Depends(get_db)):\n    item = db.query(Message).filter(Message.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Message not found\")\n    \n    update_data = updates.dict(exclude_unset=True)\n    for key, value in update_data.items():\n        setattr(item, key, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Delete a Product by ID using FastAPI and SQLAlchemy with proper error handling.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/products/{item_id}\", status_code=204)\ndef delete_product(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Product not found\")\n    db.delete(item)\n    db.commit()\n    return {\"message\": \"Product deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_6_smart_generation"}
{"instruction": "Create a FastAPI POST endpoint to create a new User with username, email, password using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    password = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass UserCreate(BaseModel):\n    username: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    password: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/users/\", status_code=status.HTTP_201_CREATED)\ndef create_user(item: UserCreate, db: Session = Depends(get_db)):\n    db_item = User(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Order's product_id in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass OrderUpdate(BaseModel):\n    customer_id: Optional[str] = Field(None, max_length=100)\n    product_id: Optional[str] = Field(None, max_length=200)\n    quantity: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/orders/{item_id}\", response_model=OrderSchema)\ndef update_order(\n    item_id: int, \n    updates: OrderUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Order not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Post from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/posts/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_post(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Post with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Post deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Invoice with customer_id, amount, due_date using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String, nullable=False, index=True)\n    amount = Column(String, nullable=False)\n    due_date = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass InvoiceCreate(BaseModel):\n    customer_id: str = Field(..., min_length=1, max_length=100)\n    amount: str = Field(..., max_length=200)\n    due_date: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/invoices/\", status_code=status.HTTP_201_CREATED)\ndef create_invoice(item: InvoiceCreate, db: Session = Depends(get_db)):\n    db_item = Invoice(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Task's description in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass TaskUpdate(BaseModel):\n    title: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=200)\n    assignee_id: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/tasks/{item_id}\", response_model=TaskSchema)\ndef update_task(\n    item_id: int, \n    updates: TaskUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Task not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a User from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/users/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_user(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"User deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Order with customer_id, product_id, quantity using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String, nullable=False, index=True)\n    product_id = Column(String, nullable=False)\n    quantity = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass OrderCreate(BaseModel):\n    customer_id: str = Field(..., min_length=1, max_length=100)\n    product_id: str = Field(..., max_length=200)\n    quantity: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/orders/\", status_code=status.HTTP_201_CREATED)\ndef create_order(item: OrderCreate, db: Session = Depends(get_db)):\n    db_item = Order(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Customer's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass CustomerUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    phone: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/customers/{item_id}\", response_model=CustomerSchema)\ndef update_customer(\n    item_id: int, \n    updates: CustomerUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Customer not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Invoice from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/invoices/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_invoice(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Invoice with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Invoice deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Task with title, description, assignee_id using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False, index=True)\n    description = Column(String, nullable=False)\n    assignee_id = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass TaskCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(..., max_length=200)\n    assignee_id: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/tasks/\", status_code=status.HTTP_201_CREATED)\ndef create_task(item: TaskCreate, db: Session = Depends(get_db)):\n    db_item = Task(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Product's price in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    price: Optional[str] = Field(None, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/products/{item_id}\", response_model=ProductSchema)\ndef update_product(\n    item_id: int, \n    updates: ProductUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Order from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/orders/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_order(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Order with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Order deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Customer with name, email, phone using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    phone = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass CustomerCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    phone: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/customers/\", status_code=status.HTTP_201_CREATED)\ndef create_customer(item: CustomerCreate, db: Session = Depends(get_db)):\n    db_item = Customer(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Employee's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass EmployeeUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    department: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/employees/{item_id}\", response_model=EmployeeSchema)\ndef update_employee(\n    item_id: int, \n    updates: EmployeeUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Employee not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Task from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/tasks/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Task with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Task deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Product with name, price, description using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    price = Column(String, nullable=False)\n    description = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    price: str = Field(..., max_length=200)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/products/\", status_code=status.HTTP_201_CREATED)\ndef create_product(item: ProductCreate, db: Session = Depends(get_db)):\n    db_item = Product(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Post's content in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass PostUpdate(BaseModel):\n    title: Optional[str] = Field(None, max_length=100)\n    content: Optional[str] = Field(None, max_length=200)\n    author_id: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/posts/{item_id}\", response_model=PostSchema)\ndef update_post(\n    item_id: int, \n    updates: PostUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Post).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Post not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Customer from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/customers/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_customer(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Customer with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Customer deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Employee with name, email, department using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    department = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass EmployeeCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    department: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/employees/\", status_code=status.HTTP_201_CREATED)\ndef create_employee(item: EmployeeCreate, db: Session = Depends(get_db)):\n    db_item = Employee(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a User's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass UserUpdate(BaseModel):\n    username: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    password: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/users/{item_id}\", response_model=UserSchema)\ndef update_user(\n    item_id: int, \n    updates: UserUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(User).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Product from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/products/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_product(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Product deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Post with title, content, author_id using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False, index=True)\n    content = Column(String, nullable=False)\n    author_id = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass PostCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=100)\n    content: str = Field(..., max_length=200)\n    author_id: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/posts/\", status_code=status.HTTP_201_CREATED)\ndef create_post(item: PostCreate, db: Session = Depends(get_db)):\n    db_item = Post(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Invoice's amount in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass InvoiceUpdate(BaseModel):\n    customer_id: Optional[str] = Field(None, max_length=100)\n    amount: Optional[str] = Field(None, max_length=200)\n    due_date: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/invoices/{item_id}\", response_model=InvoiceSchema)\ndef update_invoice(\n    item_id: int, \n    updates: InvoiceUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Invoice not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Employee from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/employees/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_employee(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Employee with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Employee deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new User with username, email, password using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    password = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass UserCreate(BaseModel):\n    username: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    password: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/users/\", status_code=status.HTTP_201_CREATED)\ndef create_user(item: UserCreate, db: Session = Depends(get_db)):\n    db_item = User(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Order's product_id in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass OrderUpdate(BaseModel):\n    customer_id: Optional[str] = Field(None, max_length=100)\n    product_id: Optional[str] = Field(None, max_length=200)\n    quantity: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/orders/{item_id}\", response_model=OrderSchema)\ndef update_order(\n    item_id: int, \n    updates: OrderUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Order not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Post from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/posts/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_post(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Post with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Post deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Invoice with customer_id, amount, due_date using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Invoice(Base):\n    __tablename__ = \"invoices\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String, nullable=False, index=True)\n    amount = Column(String, nullable=False)\n    due_date = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass InvoiceCreate(BaseModel):\n    customer_id: str = Field(..., min_length=1, max_length=100)\n    amount: str = Field(..., max_length=200)\n    due_date: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/invoices/\", status_code=status.HTTP_201_CREATED)\ndef create_invoice(item: InvoiceCreate, db: Session = Depends(get_db)):\n    db_item = Invoice(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Task's description in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass TaskUpdate(BaseModel):\n    title: Optional[str] = Field(None, max_length=100)\n    description: Optional[str] = Field(None, max_length=200)\n    assignee_id: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/tasks/{item_id}\", response_model=TaskSchema)\ndef update_task(\n    item_id: int, \n    updates: TaskUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Task not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a User from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/users/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_user(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"User deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Order with customer_id, product_id, quantity using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True, index=True)\n    customer_id = Column(String, nullable=False, index=True)\n    product_id = Column(String, nullable=False)\n    quantity = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass OrderCreate(BaseModel):\n    customer_id: str = Field(..., min_length=1, max_length=100)\n    product_id: str = Field(..., max_length=200)\n    quantity: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/orders/\", status_code=status.HTTP_201_CREATED)\ndef create_order(item: OrderCreate, db: Session = Depends(get_db)):\n    db_item = Order(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Customer's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass CustomerUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    phone: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/customers/{item_id}\", response_model=CustomerSchema)\ndef update_customer(\n    item_id: int, \n    updates: CustomerUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Customer not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Invoice from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/invoices/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_invoice(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Invoice).filter(Invoice.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Invoice with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Invoice deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Task with title, description, assignee_id using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Task(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False, index=True)\n    description = Column(String, nullable=False)\n    assignee_id = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass TaskCreate(BaseModel):\n    title: str = Field(..., min_length=1, max_length=100)\n    description: str = Field(..., max_length=200)\n    assignee_id: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/tasks/\", status_code=status.HTTP_201_CREATED)\ndef create_task(item: TaskCreate, db: Session = Depends(get_db)):\n    db_item = Task(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Product's price in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass ProductUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    price: Optional[str] = Field(None, max_length=200)\n    description: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/products/{item_id}\", response_model=ProductSchema)\ndef update_product(\n    item_id: int, \n    updates: ProductUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Order from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/orders/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_order(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Order with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Order deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Customer with name, email, phone using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    phone = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass CustomerCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    phone: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/customers/\", status_code=status.HTTP_201_CREATED)\ndef create_customer(item: CustomerCreate, db: Session = Depends(get_db)):\n    db_item = Customer(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Employee's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass EmployeeUpdate(BaseModel):\n    name: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    department: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/employees/{item_id}\", response_model=EmployeeSchema)\ndef update_employee(\n    item_id: int, \n    updates: EmployeeUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Employee).filter(Employee.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Employee not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Task from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/tasks/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_task(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Task).filter(Task.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Task with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Task deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Product with name, price, description using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Product(Base):\n    __tablename__ = \"products\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    price = Column(String, nullable=False)\n    description = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass ProductCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    price: str = Field(..., max_length=200)\n    description: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/products/\", status_code=status.HTTP_201_CREATED)\ndef create_product(item: ProductCreate, db: Session = Depends(get_db)):\n    db_item = Product(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a Post's content in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass PostUpdate(BaseModel):\n    title: Optional[str] = Field(None, max_length=100)\n    content: Optional[str] = Field(None, max_length=200)\n    author_id: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/posts/{item_id}\", response_model=PostSchema)\ndef update_post(\n    item_id: int, \n    updates: PostUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(Post).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Post not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Customer from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/customers/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_customer(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Customer with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Customer deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI POST endpoint to create a new Employee with name, email, department using SQLAlchemy.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy import create_engine, Column, Integer, String, Boolean, Float, DateTime\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session\nfrom pydantic import BaseModel, EmailStr, Field\nfrom datetime import datetime\n\napp = FastAPI()\nBase = declarative_base()\nengine = create_engine(\"sqlite:///./database.db\", connect_args={\"check_same_thread\": False})\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass Employee(Base):\n    __tablename__ = \"employees\"\n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False, index=True)\n    email = Column(String, nullable=False)\n    department = Column(String)\n    created_at = Column(DateTime, default=datetime.utcnow)\n\nBase.metadata.create_all(bind=engine)\n\nclass EmployeeCreate(BaseModel):\n    name: str = Field(..., min_length=1, max_length=100)\n    email: str = Field(..., max_length=200)\n    department: str = Field(None, max_length=500)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.post(\"/employees/\", status_code=status.HTTP_201_CREATED)\ndef create_employee(item: EmployeeCreate, db: Session = Depends(get_db)):\n    db_item = Employee(**item.dict())\n    db.add(db_item)\n    db.commit()\n    db.refresh(db_item)\n    return db_item", "category": "crud", "subcategory": "create", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a PUT endpoint to update a User's email in the database with validation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\nfrom pydantic import BaseModel, Field\nfrom typing import Optional\n\nclass UserUpdate(BaseModel):\n    username: Optional[str] = Field(None, max_length=100)\n    email: Optional[str] = Field(None, max_length=200)\n    password: Optional[str] = Field(None, max_length=500)\n\n@app.put(\"/users/{item_id}\", response_model=UserSchema)\ndef update_user(\n    item_id: int, \n    updates: UserUpdate, \n    db: Session = Depends(get_db)\n):\n    item = db.query(User).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"User not found\"\n        )\n    \n    update_data = updates.dict(exclude_unset=True)\n    for field, value in update_data.items():\n        setattr(item, field, value)\n    \n    db.commit()\n    db.refresh(item)\n    return item", "category": "crud", "subcategory": "update", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a DELETE endpoint to remove a Product from the database by ID with proper status codes.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom sqlalchemy.orm import Session\n\n@app.delete(\"/products/{item_id}\", status_code=status.HTTP_204_NO_CONTENT)\ndef delete_product(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Product).filter(Product.id == item_id).first()\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f\"Product with id {item_id} not found\"\n        )\n    db.delete(item)\n    db.commit()\n    return {\"message\": f\"Product deleted successfully\"}", "category": "crud", "subcategory": "delete", "difficulty": "easy", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_120 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_120(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_120(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_0 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_0(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_0(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_43 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_43(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_43(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_28 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_28(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_28(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_45 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_45(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_45(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_98 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_98(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_98(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_97 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_97(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_97(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_71 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_71(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_71(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_40 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_40(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_40(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_96 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_96(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_96(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_121 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_121(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_121(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_138 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_138(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_138(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_27 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_27(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_27(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_117 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_117(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_117(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_102 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_102(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_102(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_125 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_125(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_125(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_50 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_50(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_50(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_123 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_123(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_123(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_19 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_19(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_19(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_83 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_83(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_83(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_2 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_2(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_2(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_42 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_42(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_42(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_3 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_3(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_3(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_34 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_34(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_34(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_1 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_1(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_1(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_13 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_13(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_13(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_58 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_58(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_58(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_79 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_79(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_79(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_75 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_75(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_75(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_107 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_107(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_107(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_133 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_133(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_133(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_144 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_144(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_144(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_64 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_64(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_64(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_82 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_82(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_82(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_99 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_99(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_99(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_8 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_8(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_8(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_136 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_136(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_136(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_7 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_7(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_7(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_10 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_10(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_10(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_36 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_36(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_36(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_77 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_77(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_77(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_59 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_59(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_59(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_143 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_143(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_143(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_119 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_119(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_119(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_122 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_122(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_122(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_76 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_76(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_76(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_11 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_11(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_11(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_62 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_62(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_62(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_103 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_103(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_103(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Add custom exception handler for RequestValidationError in FastAPI that returns detailed JSON response.", "input": "", "output": "from fastapi import FastAPI, Request\nfrom fastapi.exceptions import RequestValidationError\nfrom fastapi.responses import JSONResponse\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\n            \"error\": \"Validation Error\",\n            \"detail\": exc.errors(),\n            \"body\": exc.body\n        }\n    )\n\n@app.post(\"/items\")\ndef create_item(item: dict):\n    return item\n", "category": "error_handling", "subcategory": "validation_error", "difficulty": "medium"}
{"instruction": "Implement FastAPI error handling with feature_113 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_113(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_113(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_87 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_87(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_87(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_35 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_35(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_35(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_140 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_140(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_140(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_32 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_32(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_32(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_104 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_104(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_104(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_30 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_30(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_30(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_46 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_46(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_46(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_129 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_129(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_129(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_74 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_74(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_74(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_128 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_128(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_128(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_17 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_17(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_17(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_131 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_131(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_131(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_63 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_63(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_63(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_108 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_108(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_108(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_44 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_44(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_44(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_49 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_49(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_49(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_101 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_101(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_101(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_52 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_52(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_52(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_109 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_109(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_109(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_126 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_126(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_126(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_93 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_93(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_93(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_31 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_31(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_31(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_130 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_130(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_130(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_80 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_80(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_80(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_111 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_111(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_111(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_61 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_61(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_61(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_132 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_132(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_132(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_124 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_124(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_124(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_110 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_110(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_110(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_70 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_70(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_70(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_118 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_118(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_118(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_25 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_25(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_25(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_14 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_14(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_14(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_142 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_142(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_142(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_100 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_100(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_100(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_78 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_78(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_78(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_12 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_12(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_12(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_81 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_81(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_81(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_67 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_67(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_67(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_116 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_116(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_116(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_146 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_146(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_146(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_134 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_134(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_134(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_41 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_41(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_41(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_16 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_16(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_16(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_66 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_66(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_66(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_51 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_51(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_51(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_88 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_88(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_88(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_92 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_92(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_92(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_39 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_39(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_39(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_91 and pattern_1", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_91(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_91(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_114 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_114(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_114(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_23 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_23(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_23(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create custom exception handlers for FastAPI with structured error responses.", "output": "from fastapi import FastAPI, HTTPException, Request\nfrom fastapi.responses import JSONResponse\nfrom pydantic import ValidationError\n\nclass CustomException(Exception):\n    def __init__(self, detail: str, status_code: int = 400):\n        self.detail = detail\n        self.status_code = status_code\n\n@app.exception_handler(CustomException)\nasync def custom_exception_handler(request: Request, exc: CustomException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"error\": exc.detail, \"path\": str(request.url)}\n    )\n\n@app.exception_handler(ValidationError)\nasync def validation_exception_handler(request: Request, exc: ValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"errors\": exc.errors(), \"message\": \"Validation failed\"}\n    )", "category": "error_handling", "subcategory": "custom_handlers", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_72 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_72(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_72(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_56 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_56(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_56(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_15 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_15(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_15(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_47 and pattern_7", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_47(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_47(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_145 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_145(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_145(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_90 and pattern_0", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_90(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_90(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_73 and pattern_3", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_73(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_73(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_139 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_139(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_139(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_18 and pattern_8", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_18(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_18(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_94 and pattern_4", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_94(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_94(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_29 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_29(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_29(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_135 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_135(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_135(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_115 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_115(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_115(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_9 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_9(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_9(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_65 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_65(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_65(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI error handling with feature_86 and pattern_6", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_86(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_86(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_89 and pattern_9", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_89(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_89(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_22 and pattern_2", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_22(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_22(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement FastAPI error handling with feature_95 and pattern_5", "output": "from fastapi import FastAPI, Request, HTTPException\nfrom fastapi.responses import JSONResponse\nfrom fastapi.exceptions import RequestValidationError\n\napp = FastAPI()\n\n@app.exception_handler(RequestValidationError)\nasync def validation_exception_handler_95(request: Request, exc: RequestValidationError):\n    return JSONResponse(\n        status_code=422,\n        content={\"detail\": exc.errors(), \"body\": exc.body}\n    )\n\n@app.exception_handler(HTTPException)\nasync def http_exception_handler_95(request: Request, exc: HTTPException):\n    return JSONResponse(\n        status_code=exc.status_code,\n        content={\"message\": exc.detail, \"path\": str(request.url)}\n    )", "category": "error_handling"}
{"instruction": "Implement global exception handling with logging for FastAPI.", "output": "from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@app.exception_handler(Exception)\nasync def global_exception_handler(request: Request, exc: Exception):\n    logger.error(f\"Unhandled exception: {exc}\", exc_info=True)\n    return JSONResponse(\n        status_code=500,\n        content={\n            \"error\": \"Internal server error\",\n            \"message\": \"An unexpected error occurred\",\n            \"request_id\": request.state.request_id if hasattr(request.state, 'request_id') else None\n        }\n    )", "category": "error_handling", "subcategory": "global_handler", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI jwt auth with feature_0 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_0\"\n\ndef create_token_0(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_0(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_0\")\nasync def protected(user = Depends(verify_token_0)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_1 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_1\"\n\ndef create_token_1(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_1(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_1\")\nasync def protected(user = Depends(verify_token_1)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_2 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_2\"\n\ndef create_token_2(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_2(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_2\")\nasync def protected(user = Depends(verify_token_2)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_3 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_3\"\n\ndef create_token_3(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_3(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_3\")\nasync def protected(user = Depends(verify_token_3)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_4 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_4\"\n\ndef create_token_4(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_4(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_4\")\nasync def protected(user = Depends(verify_token_4)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_5 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_5\"\n\ndef create_token_5(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_5(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_5\")\nasync def protected(user = Depends(verify_token_5)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_6 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_6\"\n\ndef create_token_6(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_6(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_6\")\nasync def protected(user = Depends(verify_token_6)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_7 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_7\"\n\ndef create_token_7(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_7(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_7\")\nasync def protected(user = Depends(verify_token_7)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_8 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_8\"\n\ndef create_token_8(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_8(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_8\")\nasync def protected(user = Depends(verify_token_8)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_9 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_9\"\n\ndef create_token_9(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_9(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_9\")\nasync def protected(user = Depends(verify_token_9)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_10 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_10\"\n\ndef create_token_10(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_10(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_10\")\nasync def protected(user = Depends(verify_token_10)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_11 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_11\"\n\ndef create_token_11(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_11(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_11\")\nasync def protected(user = Depends(verify_token_11)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_12 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_12\"\n\ndef create_token_12(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_12(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_12\")\nasync def protected(user = Depends(verify_token_12)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_13 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_13\"\n\ndef create_token_13(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_13(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_13\")\nasync def protected(user = Depends(verify_token_13)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_14 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_14\"\n\ndef create_token_14(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_14(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_14\")\nasync def protected(user = Depends(verify_token_14)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_15 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_15\"\n\ndef create_token_15(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_15(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_15\")\nasync def protected(user = Depends(verify_token_15)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_16 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_16\"\n\ndef create_token_16(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_16(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_16\")\nasync def protected(user = Depends(verify_token_16)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_17 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_17\"\n\ndef create_token_17(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_17(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_17\")\nasync def protected(user = Depends(verify_token_17)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_18 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_18\"\n\ndef create_token_18(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_18(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_18\")\nasync def protected(user = Depends(verify_token_18)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_19 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_19\"\n\ndef create_token_19(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_19(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_19\")\nasync def protected(user = Depends(verify_token_19)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_20 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_20\"\n\ndef create_token_20(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_20(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_20\")\nasync def protected(user = Depends(verify_token_20)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_21 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_21\"\n\ndef create_token_21(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_21(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_21\")\nasync def protected(user = Depends(verify_token_21)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_22 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_22\"\n\ndef create_token_22(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_22(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_22\")\nasync def protected(user = Depends(verify_token_22)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_23 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_23\"\n\ndef create_token_23(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_23(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_23\")\nasync def protected(user = Depends(verify_token_23)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_24 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_24\"\n\ndef create_token_24(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_24(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_24\")\nasync def protected(user = Depends(verify_token_24)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_25 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_25\"\n\ndef create_token_25(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_25(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_25\")\nasync def protected(user = Depends(verify_token_25)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_26 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_26\"\n\ndef create_token_26(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_26(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_26\")\nasync def protected(user = Depends(verify_token_26)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_27 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_27\"\n\ndef create_token_27(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_27(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_27\")\nasync def protected(user = Depends(verify_token_27)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_28 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_28\"\n\ndef create_token_28(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_28(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_28\")\nasync def protected(user = Depends(verify_token_28)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_29 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_29\"\n\ndef create_token_29(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_29(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_29\")\nasync def protected(user = Depends(verify_token_29)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_30 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_30\"\n\ndef create_token_30(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_30(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_30\")\nasync def protected(user = Depends(verify_token_30)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_31 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_31\"\n\ndef create_token_31(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_31(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_31\")\nasync def protected(user = Depends(verify_token_31)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_32 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_32\"\n\ndef create_token_32(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_32(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_32\")\nasync def protected(user = Depends(verify_token_32)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_33 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_33\"\n\ndef create_token_33(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_33(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_33\")\nasync def protected(user = Depends(verify_token_33)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_34 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_34\"\n\ndef create_token_34(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_34(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_34\")\nasync def protected(user = Depends(verify_token_34)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_35 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_35\"\n\ndef create_token_35(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_35(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_35\")\nasync def protected(user = Depends(verify_token_35)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_36 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_36\"\n\ndef create_token_36(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_36(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_36\")\nasync def protected(user = Depends(verify_token_36)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_37 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_37\"\n\ndef create_token_37(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_37(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_37\")\nasync def protected(user = Depends(verify_token_37)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_38 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_38\"\n\ndef create_token_38(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_38(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_38\")\nasync def protected(user = Depends(verify_token_38)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_39 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_39\"\n\ndef create_token_39(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_39(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_39\")\nasync def protected(user = Depends(verify_token_39)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_40 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_40\"\n\ndef create_token_40(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_40(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_40\")\nasync def protected(user = Depends(verify_token_40)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_41 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_41\"\n\ndef create_token_41(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_41(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_41\")\nasync def protected(user = Depends(verify_token_41)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_42 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_42\"\n\ndef create_token_42(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_42(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_42\")\nasync def protected(user = Depends(verify_token_42)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_43 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_43\"\n\ndef create_token_43(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_43(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_43\")\nasync def protected(user = Depends(verify_token_43)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_44 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_44\"\n\ndef create_token_44(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_44(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_44\")\nasync def protected(user = Depends(verify_token_44)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_45 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_45\"\n\ndef create_token_45(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_45(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_45\")\nasync def protected(user = Depends(verify_token_45)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_46 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_46\"\n\ndef create_token_46(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_46(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_46\")\nasync def protected(user = Depends(verify_token_46)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_47 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_47\"\n\ndef create_token_47(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_47(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_47\")\nasync def protected(user = Depends(verify_token_47)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_48 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_48\"\n\ndef create_token_48(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_48(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_48\")\nasync def protected(user = Depends(verify_token_48)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_49 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_49\"\n\ndef create_token_49(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_49(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_49\")\nasync def protected(user = Depends(verify_token_49)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_50 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_50\"\n\ndef create_token_50(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_50(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_50\")\nasync def protected(user = Depends(verify_token_50)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_51 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_51\"\n\ndef create_token_51(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_51(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_51\")\nasync def protected(user = Depends(verify_token_51)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_52 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_52\"\n\ndef create_token_52(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_52(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_52\")\nasync def protected(user = Depends(verify_token_52)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_53 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_53\"\n\ndef create_token_53(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_53(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_53\")\nasync def protected(user = Depends(verify_token_53)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_54 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_54\"\n\ndef create_token_54(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_54(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_54\")\nasync def protected(user = Depends(verify_token_54)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_55 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_55\"\n\ndef create_token_55(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_55(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_55\")\nasync def protected(user = Depends(verify_token_55)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_56 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_56\"\n\ndef create_token_56(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_56(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_56\")\nasync def protected(user = Depends(verify_token_56)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_57 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_57\"\n\ndef create_token_57(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_57(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_57\")\nasync def protected(user = Depends(verify_token_57)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_58 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_58\"\n\ndef create_token_58(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_58(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_58\")\nasync def protected(user = Depends(verify_token_58)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_59 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_59\"\n\ndef create_token_59(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_59(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_59\")\nasync def protected(user = Depends(verify_token_59)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_60 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_60\"\n\ndef create_token_60(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_60(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_60\")\nasync def protected(user = Depends(verify_token_60)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_61 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_61\"\n\ndef create_token_61(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_61(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_61\")\nasync def protected(user = Depends(verify_token_61)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_62 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_62\"\n\ndef create_token_62(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_62(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_62\")\nasync def protected(user = Depends(verify_token_62)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_63 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_63\"\n\ndef create_token_63(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_63(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_63\")\nasync def protected(user = Depends(verify_token_63)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_64 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_64\"\n\ndef create_token_64(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_64(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_64\")\nasync def protected(user = Depends(verify_token_64)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_65 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_65\"\n\ndef create_token_65(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_65(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_65\")\nasync def protected(user = Depends(verify_token_65)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_66 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_66\"\n\ndef create_token_66(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_66(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_66\")\nasync def protected(user = Depends(verify_token_66)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_67 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_67\"\n\ndef create_token_67(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_67(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_67\")\nasync def protected(user = Depends(verify_token_67)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_68 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_68\"\n\ndef create_token_68(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_68(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_68\")\nasync def protected(user = Depends(verify_token_68)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_69 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_69\"\n\ndef create_token_69(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_69(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_69\")\nasync def protected(user = Depends(verify_token_69)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_70 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_70\"\n\ndef create_token_70(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_70(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_70\")\nasync def protected(user = Depends(verify_token_70)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_71 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_71\"\n\ndef create_token_71(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_71(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_71\")\nasync def protected(user = Depends(verify_token_71)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_72 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_72\"\n\ndef create_token_72(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_72(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_72\")\nasync def protected(user = Depends(verify_token_72)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_73 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_73\"\n\ndef create_token_73(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_73(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_73\")\nasync def protected(user = Depends(verify_token_73)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_74 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_74\"\n\ndef create_token_74(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_74(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_74\")\nasync def protected(user = Depends(verify_token_74)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_75 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_75\"\n\ndef create_token_75(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_75(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_75\")\nasync def protected(user = Depends(verify_token_75)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_76 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_76\"\n\ndef create_token_76(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_76(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_76\")\nasync def protected(user = Depends(verify_token_76)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_77 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_77\"\n\ndef create_token_77(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_77(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_77\")\nasync def protected(user = Depends(verify_token_77)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_78 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_78\"\n\ndef create_token_78(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_78(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_78\")\nasync def protected(user = Depends(verify_token_78)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_79 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_79\"\n\ndef create_token_79(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_79(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_79\")\nasync def protected(user = Depends(verify_token_79)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_80 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_80\"\n\ndef create_token_80(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_80(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_80\")\nasync def protected(user = Depends(verify_token_80)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_81 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_81\"\n\ndef create_token_81(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_81(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_81\")\nasync def protected(user = Depends(verify_token_81)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_82 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_82\"\n\ndef create_token_82(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_82(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_82\")\nasync def protected(user = Depends(verify_token_82)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_83 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_83\"\n\ndef create_token_83(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_83(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_83\")\nasync def protected(user = Depends(verify_token_83)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_84 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_84\"\n\ndef create_token_84(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_84(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_84\")\nasync def protected(user = Depends(verify_token_84)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_85 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_85\"\n\ndef create_token_85(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_85(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_85\")\nasync def protected(user = Depends(verify_token_85)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_86 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_86\"\n\ndef create_token_86(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_86(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_86\")\nasync def protected(user = Depends(verify_token_86)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_87 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_87\"\n\ndef create_token_87(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_87(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_87\")\nasync def protected(user = Depends(verify_token_87)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_88 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_88\"\n\ndef create_token_88(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_88(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_88\")\nasync def protected(user = Depends(verify_token_88)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_89 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_89\"\n\ndef create_token_89(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_89(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_89\")\nasync def protected(user = Depends(verify_token_89)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_90 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_90\"\n\ndef create_token_90(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_90(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_90\")\nasync def protected(user = Depends(verify_token_90)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_91 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_91\"\n\ndef create_token_91(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_91(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_91\")\nasync def protected(user = Depends(verify_token_91)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_92 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_92\"\n\ndef create_token_92(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_92(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_92\")\nasync def protected(user = Depends(verify_token_92)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_93 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_93\"\n\ndef create_token_93(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_93(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_93\")\nasync def protected(user = Depends(verify_token_93)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_94 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_94\"\n\ndef create_token_94(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_94(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_94\")\nasync def protected(user = Depends(verify_token_94)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_95 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_95\"\n\ndef create_token_95(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_95(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_95\")\nasync def protected(user = Depends(verify_token_95)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_96 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_96\"\n\ndef create_token_96(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_96(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_96\")\nasync def protected(user = Depends(verify_token_96)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_97 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_97\"\n\ndef create_token_97(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_97(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_97\")\nasync def protected(user = Depends(verify_token_97)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_98 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_98\"\n\ndef create_token_98(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_98(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_98\")\nasync def protected(user = Depends(verify_token_98)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_99 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_99\"\n\ndef create_token_99(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_99(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_99\")\nasync def protected(user = Depends(verify_token_99)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_100 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_100\"\n\ndef create_token_100(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_100(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_100\")\nasync def protected(user = Depends(verify_token_100)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_101 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_101\"\n\ndef create_token_101(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_101(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_101\")\nasync def protected(user = Depends(verify_token_101)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_102 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_102\"\n\ndef create_token_102(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_102(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_102\")\nasync def protected(user = Depends(verify_token_102)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_103 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_103\"\n\ndef create_token_103(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_103(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_103\")\nasync def protected(user = Depends(verify_token_103)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_104 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_104\"\n\ndef create_token_104(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_104(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_104\")\nasync def protected(user = Depends(verify_token_104)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_105 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_105\"\n\ndef create_token_105(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_105(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_105\")\nasync def protected(user = Depends(verify_token_105)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_106 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_106\"\n\ndef create_token_106(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_106(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_106\")\nasync def protected(user = Depends(verify_token_106)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_107 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_107\"\n\ndef create_token_107(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_107(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_107\")\nasync def protected(user = Depends(verify_token_107)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_108 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_108\"\n\ndef create_token_108(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_108(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_108\")\nasync def protected(user = Depends(verify_token_108)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_109 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_109\"\n\ndef create_token_109(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_109(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_109\")\nasync def protected(user = Depends(verify_token_109)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_110 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_110\"\n\ndef create_token_110(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_110(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_110\")\nasync def protected(user = Depends(verify_token_110)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_111 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_111\"\n\ndef create_token_111(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_111(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_111\")\nasync def protected(user = Depends(verify_token_111)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_112 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_112\"\n\ndef create_token_112(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_112(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_112\")\nasync def protected(user = Depends(verify_token_112)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_113 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_113\"\n\ndef create_token_113(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_113(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_113\")\nasync def protected(user = Depends(verify_token_113)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_114 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_114\"\n\ndef create_token_114(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_114(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_114\")\nasync def protected(user = Depends(verify_token_114)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_115 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_115\"\n\ndef create_token_115(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_115(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_115\")\nasync def protected(user = Depends(verify_token_115)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_116 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_116\"\n\ndef create_token_116(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_116(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_116\")\nasync def protected(user = Depends(verify_token_116)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_117 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_117\"\n\ndef create_token_117(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_117(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_117\")\nasync def protected(user = Depends(verify_token_117)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_118 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_118\"\n\ndef create_token_118(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_118(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_118\")\nasync def protected(user = Depends(verify_token_118)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_119 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_119\"\n\ndef create_token_119(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_119(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_119\")\nasync def protected(user = Depends(verify_token_119)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_120 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_120\"\n\ndef create_token_120(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_120(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_120\")\nasync def protected(user = Depends(verify_token_120)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_121 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_121\"\n\ndef create_token_121(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_121(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_121\")\nasync def protected(user = Depends(verify_token_121)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_122 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_122\"\n\ndef create_token_122(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_122(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_122\")\nasync def protected(user = Depends(verify_token_122)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_123 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_123\"\n\ndef create_token_123(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_123(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_123\")\nasync def protected(user = Depends(verify_token_123)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_124 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_124\"\n\ndef create_token_124(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_124(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_124\")\nasync def protected(user = Depends(verify_token_124)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_125 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_125\"\n\ndef create_token_125(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_125(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_125\")\nasync def protected(user = Depends(verify_token_125)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_126 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_126\"\n\ndef create_token_126(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_126(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_126\")\nasync def protected(user = Depends(verify_token_126)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_127 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_127\"\n\ndef create_token_127(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_127(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_127\")\nasync def protected(user = Depends(verify_token_127)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_128 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_128\"\n\ndef create_token_128(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_128(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_128\")\nasync def protected(user = Depends(verify_token_128)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_129 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_129\"\n\ndef create_token_129(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_129(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_129\")\nasync def protected(user = Depends(verify_token_129)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_130 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_130\"\n\ndef create_token_130(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_130(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_130\")\nasync def protected(user = Depends(verify_token_130)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_131 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_131\"\n\ndef create_token_131(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_131(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_131\")\nasync def protected(user = Depends(verify_token_131)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_132 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_132\"\n\ndef create_token_132(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_132(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_132\")\nasync def protected(user = Depends(verify_token_132)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_133 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_133\"\n\ndef create_token_133(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_133(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_133\")\nasync def protected(user = Depends(verify_token_133)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_134 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_134\"\n\ndef create_token_134(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_134(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_134\")\nasync def protected(user = Depends(verify_token_134)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_135 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_135\"\n\ndef create_token_135(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_135(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_135\")\nasync def protected(user = Depends(verify_token_135)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_136 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_136\"\n\ndef create_token_136(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_136(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_136\")\nasync def protected(user = Depends(verify_token_136)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_137 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_137\"\n\ndef create_token_137(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_137(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_137\")\nasync def protected(user = Depends(verify_token_137)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_138 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_138\"\n\ndef create_token_138(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_138(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_138\")\nasync def protected(user = Depends(verify_token_138)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_139 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_139\"\n\ndef create_token_139(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_139(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_139\")\nasync def protected(user = Depends(verify_token_139)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_140 and pattern_0", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_140\"\n\ndef create_token_140(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_140(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_140\")\nasync def protected(user = Depends(verify_token_140)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_141 and pattern_1", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_141\"\n\ndef create_token_141(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_141(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_141\")\nasync def protected(user = Depends(verify_token_141)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_142 and pattern_2", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_142\"\n\ndef create_token_142(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_142(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_142\")\nasync def protected(user = Depends(verify_token_142)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_143 and pattern_3", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_143\"\n\ndef create_token_143(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_143(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_143\")\nasync def protected(user = Depends(verify_token_143)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_144 and pattern_4", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_144\"\n\ndef create_token_144(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_144(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_144\")\nasync def protected(user = Depends(verify_token_144)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_145 and pattern_5", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_145\"\n\ndef create_token_145(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_145(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_145\")\nasync def protected(user = Depends(verify_token_145)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_146 and pattern_6", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_146\"\n\ndef create_token_146(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_146(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_146\")\nasync def protected(user = Depends(verify_token_146)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_147 and pattern_7", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_147\"\n\ndef create_token_147(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_147(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_147\")\nasync def protected(user = Depends(verify_token_147)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_148 and pattern_8", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_148\"\n\ndef create_token_148(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_148(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_148\")\nasync def protected(user = Depends(verify_token_148)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Implement FastAPI jwt auth with feature_149 and pattern_9", "output": "from jose import jwt, JWTError\nfrom fastapi import Depends, HTTPException\nfrom fastapi.security import HTTPBearer\n\nsecurity = HTTPBearer()\nSECRET_KEY = \"secret_149\"\n\ndef create_token_149(data: dict):\n    return jwt.encode(data, SECRET_KEY, algorithm=\"HS256\")\n\nasync def verify_token_149(credentials = Depends(security)):\n    try:\n        payload = jwt.decode(credentials.credentials, SECRET_KEY, algorithms=[\"HS256\"])\n        return payload\n    except JWTError:\n        raise HTTPException(status_code=401)\n\n@app.get(\"/protected_149\")\nasync def protected(user = Depends(verify_token_149)):\n    return {\"user\": user}", "category": "jwt_authentication"}
{"instruction": "Create a JWT authentication system with login with token generation.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom pydantic import BaseModel\nfrom datetime import datetime, timedelta\nimport jwt\n\napp = FastAPI()\nsecurity = HTTPBearer()\n\nSECRET_KEY = \"your-secret-key-here\"\nALGORITHM = \"HS256\"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\nclass LoginRequest(BaseModel):\n    username: str\n    password: str\n\ndef create_access_token(data: dict):\n    to_encode = data.copy()\n    expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n@app.post(\"/login\")\ndef login(request: LoginRequest):\n    # Verify credentials (simplified)\n    if request.username == \"user\" and request.password == \"password\":\n        access_token = create_access_token(data={\"sub\": request.username})\n        return {\"access_token\": access_token, \"token_type\": \"bearer\"}\n    raise HTTPException(status_code=401, detail=\"Invalid credentials\")\n", "category": "jwt_authentication", "subcategory": "login with token generation"}
{"instruction": "Create a protected endpoint with JWT verification using JWT.", "output": "from fastapi import FastAPI, Depends, HTTPException, status\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nimport jwt\n\napp = FastAPI()\nsecurity = HTTPBearer()\n\nSECRET_KEY = \"your-secret-key-here\"\nALGORITHM = \"HS256\"\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Depends(security)):\n    try:\n        token = credentials.credentials\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username = payload.get(\"sub\")\n        if username is None:\n            raise HTTPException(status_code=401, detail=\"Invalid token\")\n        return username\n    except jwt.ExpiredSignatureError:\n        raise HTTPException(status_code=401, detail=\"Token expired\")\n    except jwt.JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n@app.get(\"/protected\")\ndef protected_route(username: str = Depends(verify_token)):\n    return {\"message\": f\"Hello {username}, you have access!\"}\n", "category": "jwt_authentication", "subcategory": "protected endpoint with JWT verification"}
{"instruction": "Create JWT endpoint for user registration with JWT.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom fastapi.security import HTTPBearer\nimport jwt\nfrom datetime import datetime, timedelta\n\napp = FastAPI()\nsecurity = HTTPBearer()\n\nSECRET_KEY = \"your-secret-key-here\"\nALGORITHM = \"HS256\"\n\ndef create_token(data: dict):\n    expire = datetime.utcnow() + timedelta(minutes=30)\n    data.update({\"exp\": expire})\n    return jwt.encode(data, SECRET_KEY, algorithm=ALGORITHM)\n\ndef verify_token(token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload\n    except jwt.JWTError:\n        raise HTTPException(status_code=401, detail=\"Invalid token\")\n\n@app.post(\"/auth/user-registration-with-JWT\")\ndef auth_endpoint():\n    # JWT implementation\n    pass\n", "category": "jwt_authentication", "subcategory": "user registration with JWT"}
{"instruction": "Create a FastAPI endpoint to list users with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Users).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Users).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list posts with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Posts).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Posts).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list products with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/products/\")\ndef list_products(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Products).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Products).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list orders with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Orders).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Orders).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list comments with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/comments/\")\ndef list_comments(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Comments).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Comments).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list articles with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Articles).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Articles).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list tasks with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/tasks/\")\ndef list_tasks(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Tasks).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Tasks).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list events with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/events/\")\ndef list_events(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Events).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Events).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list notifications with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/notifications/\")\ndef list_notifications(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Notifications).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Notifications).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create a FastAPI endpoint to list messages with pagination support using skip and limit parameters.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\n\napp = FastAPI()\n\n@app.get(\"/messages/\")\ndef list_messages(\n    skip: int = Query(0, ge=0, description=\"Number of items to skip\"),\n    limit: int = Query(10, ge=1, le=100, description=\"Max items to return\")\n):\n    db_query = db.query(Messages).offset(skip).limit(limit)\n    results = db_query.all()\n    total = db.query(Messages).count()\n    return {\n        \"items\": results,\n        \"skip\": skip,\n        \"limit\": limit,\n        \"total\": total\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "easy", "source": "v5_5_generation"}
{"instruction": "Create paginated users endpoint with sorting by created_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"created_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Users)\n    \n    # Apply sorting\n    sort_column = getattr(Users, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated posts endpoint with sorting by updated_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"updated_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Posts)\n    \n    # Apply sorting\n    sort_column = getattr(Posts, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated products endpoint with sorting by name.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/products/\")\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"name\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Products)\n    \n    # Apply sorting\n    sort_column = getattr(Products, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated orders endpoint with sorting by email.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"email\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Orders)\n    \n    # Apply sorting\n    sort_column = getattr(Orders, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated comments endpoint with sorting by price.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/comments/\")\ndef list_comments(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"price\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Comments)\n    \n    # Apply sorting\n    sort_column = getattr(Comments, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated articles endpoint with sorting by quantity.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"quantity\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Articles)\n    \n    # Apply sorting\n    sort_column = getattr(Articles, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated tasks endpoint with sorting by status.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/tasks/\")\ndef list_tasks(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"status\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Tasks)\n    \n    # Apply sorting\n    sort_column = getattr(Tasks, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated events endpoint with sorting by priority.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/events/\")\ndef list_events(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"priority\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Events)\n    \n    # Apply sorting\n    sort_column = getattr(Events, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated notifications endpoint with sorting by created_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/notifications/\")\ndef list_notifications(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"created_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Notifications)\n    \n    # Apply sorting\n    sort_column = getattr(Notifications, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated messages endpoint with sorting by updated_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/messages/\")\ndef list_messages(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"updated_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Messages)\n    \n    # Apply sorting\n    sort_column = getattr(Messages, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated users endpoint with sorting by name.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"name\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Users)\n    \n    # Apply sorting\n    sort_column = getattr(Users, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated posts endpoint with sorting by email.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"email\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Posts)\n    \n    # Apply sorting\n    sort_column = getattr(Posts, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated products endpoint with sorting by price.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/products/\")\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"price\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Products)\n    \n    # Apply sorting\n    sort_column = getattr(Products, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated orders endpoint with sorting by quantity.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"quantity\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Orders)\n    \n    # Apply sorting\n    sort_column = getattr(Orders, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated comments endpoint with sorting by status.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/comments/\")\ndef list_comments(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"status\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Comments)\n    \n    # Apply sorting\n    sort_column = getattr(Comments, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated articles endpoint with sorting by priority.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"priority\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Articles)\n    \n    # Apply sorting\n    sort_column = getattr(Articles, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated tasks endpoint with sorting by created_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/tasks/\")\ndef list_tasks(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"created_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Tasks)\n    \n    # Apply sorting\n    sort_column = getattr(Tasks, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated events endpoint with sorting by updated_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/events/\")\ndef list_events(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"updated_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Events)\n    \n    # Apply sorting\n    sort_column = getattr(Events, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated notifications endpoint with sorting by name.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/notifications/\")\ndef list_notifications(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"name\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Notifications)\n    \n    # Apply sorting\n    sort_column = getattr(Notifications, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated messages endpoint with sorting by email.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/messages/\")\ndef list_messages(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"email\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Messages)\n    \n    # Apply sorting\n    sort_column = getattr(Messages, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated users endpoint with sorting by price.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"price\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Users)\n    \n    # Apply sorting\n    sort_column = getattr(Users, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated posts endpoint with sorting by quantity.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"quantity\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Posts)\n    \n    # Apply sorting\n    sort_column = getattr(Posts, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated products endpoint with sorting by status.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/products/\")\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"status\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Products)\n    \n    # Apply sorting\n    sort_column = getattr(Products, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated orders endpoint with sorting by priority.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"priority\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Orders)\n    \n    # Apply sorting\n    sort_column = getattr(Orders, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated comments endpoint with sorting by created_at.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy import desc, asc\n\napp = FastAPI()\n\n@app.get(\"/comments/\")\ndef list_comments(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    sort_by: str = Query(\"created_at\", description=\"Field to sort by\"),\n    order: str = Query(\"desc\", regex=\"^(asc|desc)$\")\n):\n    query = db.query(Comments)\n    \n    # Apply sorting\n    sort_column = getattr(Comments, sort_by)\n    if order == \"desc\":\n        query = query.order_by(desc(sort_column))\n    else:\n        query = query.order_by(asc(sort_column))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"sort\": {\"by\": sort_by, \"order\": order}\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated users endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Users)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Users.status == status)\n    if search:\n        query = query.filter(Users.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated posts endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Posts)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Posts.status == status)\n    if search:\n        query = query.filter(Posts.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated products endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/products/\")\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Products)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Products.status == status)\n    if search:\n        query = query.filter(Products.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated orders endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Orders)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Orders.status == status)\n    if search:\n        query = query.filter(Orders.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated comments endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/comments/\")\ndef list_comments(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Comments)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Comments.status == status)\n    if search:\n        query = query.filter(Comments.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated articles endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Articles)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Articles.status == status)\n    if search:\n        query = query.filter(Articles.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated tasks endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/tasks/\")\ndef list_tasks(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Tasks)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Tasks.status == status)\n    if search:\n        query = query.filter(Tasks.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated events endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/events/\")\ndef list_events(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Events)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Events.status == status)\n    if search:\n        query = query.filter(Events.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated notifications endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/notifications/\")\ndef list_notifications(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Notifications)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Notifications.status == status)\n    if search:\n        query = query.filter(Notifications.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Implement paginated messages endpoint with status filtering.", "output": "from fastapi import FastAPI, Query\nfrom typing import Optional\n\napp = FastAPI()\n\n@app.get(\"/messages/\")\ndef list_messages(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    status: Optional[str] = Query(None, description=\"Filter by status\"),\n    search: Optional[str] = Query(None, description=\"Search term\")\n):\n    query = db.query(Messages)\n    \n    # Apply filters\n    if status:\n        query = query.filter(Messages.status == status)\n    if search:\n        query = query.filter(Messages.name.contains(search))\n    \n    total = query.count()\n    items = query.offset(skip).limit(limit).all()\n    \n    return {\n        \"items\": items,\n        \"pagination\": {\n            \"skip\": skip,\n            \"limit\": limit,\n            \"total\": total\n        },\n        \"filters\": {\n            \"status\": status,\n            \"search\": search\n        }\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_5_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Users with skip limit in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/users/\")\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Posts with page based in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/posts/\")\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "page_based", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Orders with with sorting in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/orders/\")\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_sorting", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create paginated endpoint for Articles with with filtering in FastAPI.", "output": "from fastapi import FastAPI, Query\nfrom sqlalchemy.orm import Session\n\n@app.get(\"/articles/\")\ndef list_articles(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(20, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Article).count()\n    items = db.query(Article).offset(skip).limit(limit).all()\n    return {\n        \"items\": items,\n        \"total\": total,\n        \"skip\": skip,\n        \"limit\": limit\n    }", "category": "pagination", "subcategory": "with_filtering", "difficulty": "medium", "source": "v5_6_smart_generation"}
{"instruction": "Create a paginated endpoint to list Users with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[UserSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/users/\", response_model=PaginatedResponse)\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Orders with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[OrderSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/orders/\", response_model=PaginatedResponse)\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Products with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[ProductSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/products/\", response_model=PaginatedResponse)\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Product).count()\n    items = db.query(Product).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Customers with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[CustomerSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/customers/\", response_model=PaginatedResponse)\ndef list_customers(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Customer).count()\n    items = db.query(Customer).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Posts with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[PostSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/posts/\", response_model=PaginatedResponse)\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Users with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[UserSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/users/\", response_model=PaginatedResponse)\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Orders with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[OrderSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/orders/\", response_model=PaginatedResponse)\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Products with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[ProductSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/products/\", response_model=PaginatedResponse)\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Product).count()\n    items = db.query(Product).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Customers with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[CustomerSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/customers/\", response_model=PaginatedResponse)\ndef list_customers(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Customer).count()\n    items = db.query(Customer).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Posts with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[PostSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/posts/\", response_model=PaginatedResponse)\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Users with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[UserSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/users/\", response_model=PaginatedResponse)\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Orders with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[OrderSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/orders/\", response_model=PaginatedResponse)\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Products with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[ProductSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/products/\", response_model=PaginatedResponse)\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Product).count()\n    items = db.query(Product).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Customers with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[CustomerSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/customers/\", response_model=PaginatedResponse)\ndef list_customers(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Customer).count()\n    items = db.query(Customer).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Posts with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[PostSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/posts/\", response_model=PaginatedResponse)\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Users with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[UserSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/users/\", response_model=PaginatedResponse)\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Orders with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[OrderSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/orders/\", response_model=PaginatedResponse)\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Products with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[ProductSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/products/\", response_model=PaginatedResponse)\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Product).count()\n    items = db.query(Product).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Customers with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[CustomerSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/customers/\", response_model=PaginatedResponse)\ndef list_customers(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Customer).count()\n    items = db.query(Customer).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Posts with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[PostSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/posts/\", response_model=PaginatedResponse)\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Users with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[UserSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/users/\", response_model=PaginatedResponse)\ndef list_users(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(User).count()\n    items = db.query(User).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Orders with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[OrderSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/orders/\", response_model=PaginatedResponse)\ndef list_orders(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Order).count()\n    items = db.query(Order).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Products with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[ProductSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/products/\", response_model=PaginatedResponse)\ndef list_products(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Product).count()\n    items = db.query(Product).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Customers with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[CustomerSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/customers/\", response_model=PaginatedResponse)\ndef list_customers(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Customer).count()\n    items = db.query(Customer).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a paginated endpoint to list Posts with skip and limit parameters and total count.", "output": "from fastapi import FastAPI, Depends, Query\nfrom sqlalchemy.orm import Session\nfrom typing import List\nfrom pydantic import BaseModel\n\nclass PaginatedResponse(BaseModel):\n    items: List[PostSchema]\n    total: int\n    skip: int\n    limit: int\n\n@app.get(\"/posts/\", response_model=PaginatedResponse)\ndef list_posts(\n    skip: int = Query(0, ge=0),\n    limit: int = Query(10, ge=1, le=100),\n    db: Session = Depends(get_db)\n):\n    total = db.query(Post).count()\n    items = db.query(Post).offset(skip).limit(limit).all()\n    return PaginatedResponse(items=items, total=total, skip=skip, limit=limit)", "category": "pagination", "subcategory": "skip_limit", "difficulty": "medium", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using joinedload for efficient querying of Company, Department, and Employee relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with three-level relationships\n- Implement joinedload to prevent N+1 query problem\n- Create an endpoint that fetches Company with all related Department and Employee in a single query\n- Show proper use of options() with joinedload()", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass CompanyModel(Base):\n    __tablename__ = \"companies\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    departments = relationship(\n        \"DepartmentModel\",\n        back_populates=\"company\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass DepartmentModel(Base):\n    __tablename__ = \"departments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    company_id = Column(Integer, ForeignKey(\"companies.id\"), nullable=False)\n    \n    company = relationship(\"CompanyModel\", back_populates=\"departments\")\n    employees = relationship(\n        \"EmployeeModel\",\n        back_populates=\"department\",\n        lazy='selectin'\n    )\n\nclass EmployeeModel(Base):\n    __tablename__ = \"employees\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    department_id = Column(Integer, ForeignKey(\"departments.id\"), nullable=False)\n    \n    department = relationship(\"DepartmentModel\", back_populates=\"employees\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass EmployeeResponse(BaseModel):\n    id: int\n    text: str\n    department_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass DepartmentResponse(BaseModel):\n    id: int\n    title: str\n    company_id: int\n    employees: List[EmployeeResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass CompanyResponse(BaseModel):\n    id: int\n    name: str\n    departments: List[DepartmentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/companies/{item_id}/optimized\", response_model=CompanyResponse)\ndef get_company_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using joinedload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use joinedload for efficient single-query fetch\n    item = db.query(CompanyModel).options(\n        joinedload(CompanyModel.departments).joinedload(DepartmentModel.employees)\n    ).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    return item\n\n@app.get(\"/companies/{item_id}/naive\", response_model=CompanyResponse)\ndef get_company_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(CompanyModel).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.departments  # Triggers query for each relationship access\n    for child in item.departments:\n        _ = child.employees  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/companies/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM demonstrating different lazy loading strategies for Order, OrderItem, and Product relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Show different lazy loading strategies: 'select', 'joined', 'selectin', 'subquery'\n- Implement relationships with lazy='selectin' for automatic optimization\n- Create endpoints showing the impact of lazy loading strategies", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass OrderModel(Base):\n    __tablename__ = \"orders\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    order_items = relationship(\n        \"OrderItemModel\",\n        back_populates=\"order\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass OrderItemModel(Base):\n    __tablename__ = \"order_items\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"), nullable=False)\n    \n    order = relationship(\"OrderModel\", back_populates=\"order_items\")\n    products = relationship(\n        \"ProductModel\",\n        back_populates=\"orderitem\",\n        lazy='selectin'\n    )\n\nclass ProductModel(Base):\n    __tablename__ = \"products\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    orderitem_id = Column(Integer, ForeignKey(\"order_items.id\"), nullable=False)\n    \n    orderitem = relationship(\"OrderItemModel\", back_populates=\"products\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass ProductResponse(BaseModel):\n    id: int\n    text: str\n    orderitem_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass OrderItemResponse(BaseModel):\n    id: int\n    title: str\n    order_id: int\n    products: List[ProductResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass OrderResponse(BaseModel):\n    id: int\n    name: str\n    order_items: List[OrderItemResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/orders/{item_id}/optimized\", response_model=OrderResponse)\ndef get_order_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using lazy_strategies to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Lazy strategy handles loading automatically\n    item = db.query(OrderModel).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item\n\n@app.get(\"/orders/{item_id}/naive\", response_model=OrderResponse)\ndef get_order_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(OrderModel).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.order_items  # Triggers query for each relationship access\n    for child in item.order_items:\n        _ = child.products  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/orders/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using subqueryload for collections in User, Post, and Comment relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Implement subqueryload for efficient loading of collections\n- Show proper use of options() with subqueryload()\n- Create endpoints demonstrating query optimization", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    posts = relationship(\n        \"PostModel\",\n        back_populates=\"user\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass PostModel(Base):\n    __tablename__ = \"posts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    \n    user = relationship(\"UserModel\", back_populates=\"posts\")\n    comments = relationship(\n        \"CommentModel\",\n        back_populates=\"post\",\n        lazy='selectin'\n    )\n\nclass CommentModel(Base):\n    __tablename__ = \"comments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    post_id = Column(Integer, ForeignKey(\"posts.id\"), nullable=False)\n    \n    post = relationship(\"PostModel\", back_populates=\"comments\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass CommentResponse(BaseModel):\n    id: int\n    text: str\n    post_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass PostResponse(BaseModel):\n    id: int\n    title: str\n    user_id: int\n    comments: List[CommentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    posts: List[PostResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/{item_id}/optimized\", response_model=UserResponse)\ndef get_user_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using subqueryload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use subqueryload for efficient collection loading\n    item = db.query(UserModel).options(\n        subqueryload(UserModel.posts).subqueryload(PostModel.comments)\n    ).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item\n\n@app.get(\"/users/{item_id}/naive\", response_model=UserResponse)\ndef get_user_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(UserModel).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.posts  # Triggers query for each relationship access\n    for child in item.posts:\n        _ = child.comments  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/users/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using joinedload for efficient querying of User, Post, and Comment relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with three-level relationships\n- Implement joinedload to prevent N+1 query problem\n- Create an endpoint that fetches User with all related Post and Comment in a single query\n- Show proper use of options() with joinedload()", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    posts = relationship(\n        \"PostModel\",\n        back_populates=\"user\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass PostModel(Base):\n    __tablename__ = \"posts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    \n    user = relationship(\"UserModel\", back_populates=\"posts\")\n    comments = relationship(\n        \"CommentModel\",\n        back_populates=\"post\",\n        lazy='selectin'\n    )\n\nclass CommentModel(Base):\n    __tablename__ = \"comments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    post_id = Column(Integer, ForeignKey(\"posts.id\"), nullable=False)\n    \n    post = relationship(\"PostModel\", back_populates=\"comments\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass CommentResponse(BaseModel):\n    id: int\n    text: str\n    post_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass PostResponse(BaseModel):\n    id: int\n    title: str\n    user_id: int\n    comments: List[CommentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    posts: List[PostResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/{item_id}/optimized\", response_model=UserResponse)\ndef get_user_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using joinedload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use joinedload for efficient single-query fetch\n    item = db.query(UserModel).options(\n        joinedload(UserModel.posts).joinedload(PostModel.comments)\n    ).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item\n\n@app.get(\"/users/{item_id}/naive\", response_model=UserResponse)\ndef get_user_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(UserModel).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.posts  # Triggers query for each relationship access\n    for child in item.posts:\n        _ = child.comments  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/users/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using selectinload for efficient querying of User, Post, and Comment relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with relationships\n- Implement selectinload for efficient loading of related objects\n- Create an endpoint that uses selectinload to optimize queries\n- Show the difference between lazy loading and selectinload", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    posts = relationship(\n        \"PostModel\",\n        back_populates=\"user\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass PostModel(Base):\n    __tablename__ = \"posts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    \n    user = relationship(\"UserModel\", back_populates=\"posts\")\n    comments = relationship(\n        \"CommentModel\",\n        back_populates=\"post\",\n        lazy='selectin'\n    )\n\nclass CommentModel(Base):\n    __tablename__ = \"comments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    post_id = Column(Integer, ForeignKey(\"posts.id\"), nullable=False)\n    \n    post = relationship(\"PostModel\", back_populates=\"comments\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass CommentResponse(BaseModel):\n    id: int\n    text: str\n    post_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass PostResponse(BaseModel):\n    id: int\n    title: str\n    user_id: int\n    comments: List[CommentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    posts: List[PostResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/{item_id}/optimized\", response_model=UserResponse)\ndef get_user_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using selectinload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use selectinload for efficient separate-query fetch\n    item = db.query(UserModel).options(\n        selectinload(UserModel.posts).selectinload(PostModel.comments)\n    ).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item\n\n@app.get(\"/users/{item_id}/naive\", response_model=UserResponse)\ndef get_user_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(UserModel).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.posts  # Triggers query for each relationship access\n    for child in item.posts:\n        _ = child.comments  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/users/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using joinedload for efficient querying of Order, OrderItem, and Product relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with three-level relationships\n- Implement joinedload to prevent N+1 query problem\n- Create an endpoint that fetches Order with all related OrderItem and Product in a single query\n- Show proper use of options() with joinedload()", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass OrderModel(Base):\n    __tablename__ = \"orders\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    order_items = relationship(\n        \"OrderItemModel\",\n        back_populates=\"order\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass OrderItemModel(Base):\n    __tablename__ = \"order_items\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"), nullable=False)\n    \n    order = relationship(\"OrderModel\", back_populates=\"order_items\")\n    products = relationship(\n        \"ProductModel\",\n        back_populates=\"orderitem\",\n        lazy='selectin'\n    )\n\nclass ProductModel(Base):\n    __tablename__ = \"products\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    orderitem_id = Column(Integer, ForeignKey(\"order_items.id\"), nullable=False)\n    \n    orderitem = relationship(\"OrderItemModel\", back_populates=\"products\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass ProductResponse(BaseModel):\n    id: int\n    text: str\n    orderitem_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass OrderItemResponse(BaseModel):\n    id: int\n    title: str\n    order_id: int\n    products: List[ProductResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass OrderResponse(BaseModel):\n    id: int\n    name: str\n    order_items: List[OrderItemResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/orders/{item_id}/optimized\", response_model=OrderResponse)\ndef get_order_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using joinedload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use joinedload for efficient single-query fetch\n    item = db.query(OrderModel).options(\n        joinedload(OrderModel.order_items).joinedload(OrderItemModel.products)\n    ).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item\n\n@app.get(\"/orders/{item_id}/naive\", response_model=OrderResponse)\ndef get_order_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(OrderModel).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.order_items  # Triggers query for each relationship access\n    for child in item.order_items:\n        _ = child.products  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/orders/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using subqueryload for collections in Order, OrderItem, and Product relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Implement subqueryload for efficient loading of collections\n- Show proper use of options() with subqueryload()\n- Create endpoints demonstrating query optimization", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass OrderModel(Base):\n    __tablename__ = \"orders\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    order_items = relationship(\n        \"OrderItemModel\",\n        back_populates=\"order\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass OrderItemModel(Base):\n    __tablename__ = \"order_items\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"), nullable=False)\n    \n    order = relationship(\"OrderModel\", back_populates=\"order_items\")\n    products = relationship(\n        \"ProductModel\",\n        back_populates=\"orderitem\",\n        lazy='selectin'\n    )\n\nclass ProductModel(Base):\n    __tablename__ = \"products\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    orderitem_id = Column(Integer, ForeignKey(\"order_items.id\"), nullable=False)\n    \n    orderitem = relationship(\"OrderItemModel\", back_populates=\"products\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass ProductResponse(BaseModel):\n    id: int\n    text: str\n    orderitem_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass OrderItemResponse(BaseModel):\n    id: int\n    title: str\n    order_id: int\n    products: List[ProductResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass OrderResponse(BaseModel):\n    id: int\n    name: str\n    order_items: List[OrderItemResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/orders/{item_id}/optimized\", response_model=OrderResponse)\ndef get_order_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using subqueryload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use subqueryload for efficient collection loading\n    item = db.query(OrderModel).options(\n        subqueryload(OrderModel.order_items).subqueryload(OrderItemModel.products)\n    ).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item\n\n@app.get(\"/orders/{item_id}/naive\", response_model=OrderResponse)\ndef get_order_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(OrderModel).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.order_items  # Triggers query for each relationship access\n    for child in item.order_items:\n        _ = child.products  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/orders/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM demonstrating different lazy loading strategies for Company, Department, and Employee relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Show different lazy loading strategies: 'select', 'joined', 'selectin', 'subquery'\n- Implement relationships with lazy='selectin' for automatic optimization\n- Create endpoints showing the impact of lazy loading strategies", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass CompanyModel(Base):\n    __tablename__ = \"companies\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    departments = relationship(\n        \"DepartmentModel\",\n        back_populates=\"company\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass DepartmentModel(Base):\n    __tablename__ = \"departments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    company_id = Column(Integer, ForeignKey(\"companies.id\"), nullable=False)\n    \n    company = relationship(\"CompanyModel\", back_populates=\"departments\")\n    employees = relationship(\n        \"EmployeeModel\",\n        back_populates=\"department\",\n        lazy='selectin'\n    )\n\nclass EmployeeModel(Base):\n    __tablename__ = \"employees\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    department_id = Column(Integer, ForeignKey(\"departments.id\"), nullable=False)\n    \n    department = relationship(\"DepartmentModel\", back_populates=\"employees\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass EmployeeResponse(BaseModel):\n    id: int\n    text: str\n    department_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass DepartmentResponse(BaseModel):\n    id: int\n    title: str\n    company_id: int\n    employees: List[EmployeeResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass CompanyResponse(BaseModel):\n    id: int\n    name: str\n    departments: List[DepartmentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/companies/{item_id}/optimized\", response_model=CompanyResponse)\ndef get_company_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using lazy_strategies to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Lazy strategy handles loading automatically\n    item = db.query(CompanyModel).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    return item\n\n@app.get(\"/companies/{item_id}/naive\", response_model=CompanyResponse)\ndef get_company_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(CompanyModel).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.departments  # Triggers query for each relationship access\n    for child in item.departments:\n        _ = child.employees  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/companies/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using subqueryload for collections in Company, Department, and Employee relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Implement subqueryload for efficient loading of collections\n- Show proper use of options() with subqueryload()\n- Create endpoints demonstrating query optimization", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass CompanyModel(Base):\n    __tablename__ = \"companies\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    departments = relationship(\n        \"DepartmentModel\",\n        back_populates=\"company\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass DepartmentModel(Base):\n    __tablename__ = \"departments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    company_id = Column(Integer, ForeignKey(\"companies.id\"), nullable=False)\n    \n    company = relationship(\"CompanyModel\", back_populates=\"departments\")\n    employees = relationship(\n        \"EmployeeModel\",\n        back_populates=\"department\",\n        lazy='selectin'\n    )\n\nclass EmployeeModel(Base):\n    __tablename__ = \"employees\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    department_id = Column(Integer, ForeignKey(\"departments.id\"), nullable=False)\n    \n    department = relationship(\"DepartmentModel\", back_populates=\"employees\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass EmployeeResponse(BaseModel):\n    id: int\n    text: str\n    department_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass DepartmentResponse(BaseModel):\n    id: int\n    title: str\n    company_id: int\n    employees: List[EmployeeResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass CompanyResponse(BaseModel):\n    id: int\n    name: str\n    departments: List[DepartmentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/companies/{item_id}/optimized\", response_model=CompanyResponse)\ndef get_company_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using subqueryload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use subqueryload for efficient collection loading\n    item = db.query(CompanyModel).options(\n        subqueryload(CompanyModel.departments).subqueryload(DepartmentModel.employees)\n    ).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    return item\n\n@app.get(\"/companies/{item_id}/naive\", response_model=CompanyResponse)\ndef get_company_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(CompanyModel).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.departments  # Triggers query for each relationship access\n    for child in item.departments:\n        _ = child.employees  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/companies/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using selectinload for efficient querying of Company, Department, and Employee relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with relationships\n- Implement selectinload for efficient loading of related objects\n- Create an endpoint that uses selectinload to optimize queries\n- Show the difference between lazy loading and selectinload", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass CompanyModel(Base):\n    __tablename__ = \"companies\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    departments = relationship(\n        \"DepartmentModel\",\n        back_populates=\"company\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass DepartmentModel(Base):\n    __tablename__ = \"departments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    company_id = Column(Integer, ForeignKey(\"companies.id\"), nullable=False)\n    \n    company = relationship(\"CompanyModel\", back_populates=\"departments\")\n    employees = relationship(\n        \"EmployeeModel\",\n        back_populates=\"department\",\n        lazy='selectin'\n    )\n\nclass EmployeeModel(Base):\n    __tablename__ = \"employees\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    department_id = Column(Integer, ForeignKey(\"departments.id\"), nullable=False)\n    \n    department = relationship(\"DepartmentModel\", back_populates=\"employees\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass EmployeeResponse(BaseModel):\n    id: int\n    text: str\n    department_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass DepartmentResponse(BaseModel):\n    id: int\n    title: str\n    company_id: int\n    employees: List[EmployeeResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass CompanyResponse(BaseModel):\n    id: int\n    name: str\n    departments: List[DepartmentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/companies/{item_id}/optimized\", response_model=CompanyResponse)\ndef get_company_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using selectinload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use selectinload for efficient separate-query fetch\n    item = db.query(CompanyModel).options(\n        selectinload(CompanyModel.departments).selectinload(DepartmentModel.employees)\n    ).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    return item\n\n@app.get(\"/companies/{item_id}/naive\", response_model=CompanyResponse)\ndef get_company_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(CompanyModel).filter(CompanyModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Company not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.departments  # Triggers query for each relationship access\n    for child in item.departments:\n        _ = child.employees  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/companies/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM demonstrating different lazy loading strategies for User, Post, and Comment relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base\n- Show different lazy loading strategies: 'select', 'joined', 'selectin', 'subquery'\n- Implement relationships with lazy='selectin' for automatic optimization\n- Create endpoints showing the impact of lazy loading strategies", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass UserModel(Base):\n    __tablename__ = \"users\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    posts = relationship(\n        \"PostModel\",\n        back_populates=\"user\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass PostModel(Base):\n    __tablename__ = \"posts\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    user_id = Column(Integer, ForeignKey(\"users.id\"), nullable=False)\n    \n    user = relationship(\"UserModel\", back_populates=\"posts\")\n    comments = relationship(\n        \"CommentModel\",\n        back_populates=\"post\",\n        lazy='selectin'\n    )\n\nclass CommentModel(Base):\n    __tablename__ = \"comments\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    post_id = Column(Integer, ForeignKey(\"posts.id\"), nullable=False)\n    \n    post = relationship(\"PostModel\", back_populates=\"comments\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass CommentResponse(BaseModel):\n    id: int\n    text: str\n    post_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass PostResponse(BaseModel):\n    id: int\n    title: str\n    user_id: int\n    comments: List[CommentResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass UserResponse(BaseModel):\n    id: int\n    name: str\n    posts: List[PostResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/users/{item_id}/optimized\", response_model=UserResponse)\ndef get_user_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using lazy_strategies to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Lazy strategy handles loading automatically\n    item = db.query(UserModel).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item\n\n@app.get(\"/users/{item_id}/naive\", response_model=UserResponse)\ndef get_user_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(UserModel).filter(UserModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.posts  # Triggers query for each relationship access\n    for child in item.posts:\n        _ = child.comments  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/users/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI application with SQLAlchemy ORM using selectinload for efficient querying of Order, OrderItem, and Product relationships.\n\nRequirements:\n- Use SQLAlchemy declarative base with relationships\n- Implement selectinload for efficient loading of related objects\n- Create an endpoint that uses selectinload to optimize queries\n- Show the difference between lazy loading and selectinload", "input": "", "output": "from fastapi import FastAPI, HTTPException, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey, Text\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import Session, sessionmaker, relationship, joinedload, selectinload, subqueryload\nfrom pydantic import BaseModel\nfrom typing import List, Optional\n\n# Database setup\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL, connect_args={\"check_same_thread\": False}, echo=True)  # echo=True to see queries\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\nBase = declarative_base()\n\n# SQLAlchemy ORM Models\nclass OrderModel(Base):\n    __tablename__ = \"orders\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    name = Column(String, nullable=False)\n    \n    order_items = relationship(\n        \"OrderItemModel\",\n        back_populates=\"order\",\n        lazy='selectin'  # Efficient lazy loading strategy\n    )\n\nclass OrderItemModel(Base):\n    __tablename__ = \"order_items\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    title = Column(String, nullable=False)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"), nullable=False)\n    \n    order = relationship(\"OrderModel\", back_populates=\"order_items\")\n    products = relationship(\n        \"ProductModel\",\n        back_populates=\"orderitem\",\n        lazy='selectin'\n    )\n\nclass ProductModel(Base):\n    __tablename__ = \"products\"\n    \n    id = Column(Integer, primary_key=True, index=True)\n    text = Column(Text, nullable=False)\n    orderitem_id = Column(Integer, ForeignKey(\"order_items.id\"), nullable=False)\n    \n    orderitem = relationship(\"OrderItemModel\", back_populates=\"products\")\n\nBase.metadata.create_all(bind=engine)\n\n# Pydantic Schemas\nclass ProductResponse(BaseModel):\n    id: int\n    text: str\n    orderitem_id: int\n    \n    class Config:\n        from_attributes = True\n\nclass OrderItemResponse(BaseModel):\n    id: int\n    title: str\n    order_id: int\n    products: List[ProductResponse] = []\n    \n    class Config:\n        from_attributes = True\n\nclass OrderResponse(BaseModel):\n    id: int\n    name: str\n    order_items: List[OrderItemResponse] = []\n    \n    class Config:\n        from_attributes = True\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\napp = FastAPI()\n\n@app.get(\"/orders/{item_id}/optimized\", response_model=OrderResponse)\ndef get_order_optimized(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Optimized endpoint using selectinload to prevent N+1 queries.\n    Check console output to see the number of SQL queries executed.\n    \"\"\"\n    # Use selectinload for efficient separate-query fetch\n    item = db.query(OrderModel).options(\n        selectinload(OrderModel.order_items).selectinload(OrderItemModel.products)\n    ).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item\n\n@app.get(\"/orders/{item_id}/naive\", response_model=OrderResponse)\ndef get_order_naive(item_id: int, db: Session = Depends(get_db)):\n    \"\"\"\n    Naive endpoint without optimization - causes N+1 query problem.\n    Compare query count with optimized endpoint.\n    \"\"\"\n    item = db.query(OrderModel).filter(OrderModel.id == item_id).first()\n    \n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    \n    # Accessing relationships triggers additional queries\n    _ = item.order_items  # Triggers query for each relationship access\n    for child in item.order_items:\n        _ = child.products  # Triggers query for each nested relationship\n    \n    return item\n\n@app.get(\"/orders/compare\")\ndef compare_query_strategies(db: Session = Depends(get_db)):\n    \"\"\"\n    Endpoint to demonstrate different loading strategies.\n    Returns information about query optimization.\n    \"\"\"\n    return {\n        \"message\": \"Check server logs to compare SQL queries\",\n        \"strategies\": {\n            \"joinedload\": \"Single LEFT OUTER JOIN query\",\n            \"selectinload\": \"Separate SELECT IN queries (2-3 queries total)\",\n            \"subqueryload\": \"Subquery for collections\",\n            \"lazy='selectin'\": \"Automatic selectinload on access\",\n            \"naive\": \"N+1 queries (1 + N children + N*M grandchildren)\"\n        },\n        \"recommendation\": \"Use joinedload for small result sets, selectinload for large collections\"\n    }\n", "source_phase": "1B_ORM_Enhancement", "category": "query_optimization"}
{"instruction": "Create a FastAPI endpoint to load user with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session, relationship, joinedload\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass User(Base):\n    __tablename__ = \"users\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    posts = relationship(\"Posts\", back_populates=\"user\")\n\nclass Posts(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    user_id = Column(Integer, ForeignKey(\"users.id\"))\n    user = relationship(\"User\", back_populates=\"posts\")\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/users/{item_id}\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    return user\n", "category": "query_optimization", "subcategory": "joinedload"}
{"instruction": "Create a FastAPI endpoint to load post with comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session, relationship, selectinload\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Post(Base):\n    __tablename__ = \"posts\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    comments = relationship(\"Comments\", back_populates=\"post\")\n\nclass Comments(Base):\n    __tablename__ = \"comments\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    post_id = Column(Integer, ForeignKey(\"posts.id\"))\n    post = relationship(\"Post\", back_populates=\"comments\")\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/posts/{item_id}\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    return post\n", "category": "query_optimization", "subcategory": "selectinload"}
{"instruction": "Create a FastAPI endpoint to load order with items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session, relationship, joinedload\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Order(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    items = relationship(\"Items\", back_populates=\"order\")\n\nclass Items(Base):\n    __tablename__ = \"items\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    order_id = Column(Integer, ForeignKey(\"orders.id\"))\n    order = relationship(\"Order\", back_populates=\"items\")\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/orders/{item_id}\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    order = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    return order\n", "category": "query_optimization", "subcategory": "joinedload"}
{"instruction": "Create a FastAPI endpoint to load customer with orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session, relationship, selectinload\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Customer(Base):\n    __tablename__ = \"customers\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    orders = relationship(\"Orders\", back_populates=\"customer\")\n\nclass Orders(Base):\n    __tablename__ = \"orders\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    customer_id = Column(Integer, ForeignKey(\"customers.id\"))\n    customer = relationship(\"Customer\", back_populates=\"orders\")\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/customers/{item_id}\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    customer = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    return customer\n", "category": "query_optimization", "subcategory": "selectinload"}
{"instruction": "Create a FastAPI endpoint to load project with tasks using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy import create_engine, Column, Integer, String, ForeignKey\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, Session, relationship, joinedload\n\nDATABASE_URL = \"sqlite:///./test.db\"\nengine = create_engine(DATABASE_URL)\nSessionLocal = sessionmaker(bind=engine)\nBase = declarative_base()\n\napp = FastAPI()\n\nclass Project(Base):\n    __tablename__ = \"projects\"\n    id = Column(Integer, primary_key=True)\n    name = Column(String)\n    tasks = relationship(\"Tasks\", back_populates=\"project\")\n\nclass Tasks(Base):\n    __tablename__ = \"tasks\"\n    id = Column(Integer, primary_key=True)\n    title = Column(String)\n    project_id = Column(Integer, ForeignKey(\"projects.id\"))\n    project = relationship(\"Project\", back_populates=\"tasks\")\n\nBase.metadata.create_all(bind=engine)\n\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\n@app.get(\"/projects/{item_id}\")\ndef get_project_with_tasks(item_id: int, db: Session = Depends(get_db)):\n    project = db.query(Project).options(joinedload(Project.tasks)).filter(Project.id == item_id).first()\n    return project\n", "category": "query_optimization", "subcategory": "joinedload"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Optimize a FastAPI endpoint to load User with Posts using joinedload to prevent N+1 queries.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{user_id}/with-posts\")\ndef get_user_with_posts(user_id: int, db: Session = Depends(get_db)):\n    user = db.query(User).options(joinedload(User.posts)).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return user", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Use selectinload to efficiently load Post with Comments in FastAPI.", "output": "from fastapi import FastAPI, Depends\nfrom sqlalchemy.orm import Session, selectinload\n\n@app.get(\"/posts/{post_id}/with-comments\")\ndef get_post_with_comments(post_id: int, db: Session = Depends(get_db)):\n    post = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == post_id).first()\n    if not post:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return post", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_6_smart_generation"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Users with their posts using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/users/{item_id}/with-posts\")\ndef get_user_with_posts(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(User).options(joinedload(User.posts)).filter(User.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"User not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Posts with their comments using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/posts/{item_id}/with-comments\")\ndef get_post_with_comments(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Post).options(selectinload(Post.comments)).filter(Post.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Post not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Orders with their items using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/orders/{item_id}/with-items\")\ndef get_order_with_items(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Order).options(joinedload(Order.items)).filter(Order.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Order not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Customers with their orders using selectinload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, selectinload\nfrom sqlalchemy import select\n\n@app.get(\"/customers/{item_id}/with-orders\")\ndef get_customer_with_orders(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Customer).options(selectinload(Customer.orders)).filter(Customer.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Customer not found\")\n    return item", "category": "query_optimization", "subcategory": "selectinload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a FastAPI endpoint to fetch Authors with their books using joinedload to avoid N+1 queries.", "output": "from fastapi import FastAPI, Depends, HTTPException\nfrom sqlalchemy.orm import Session, joinedload\nfrom sqlalchemy import select\n\n@app.get(\"/authors/{item_id}/with-books\")\ndef get_author_with_books(item_id: int, db: Session = Depends(get_db)):\n    item = db.query(Author).options(joinedload(Author.books)).filter(Author.id == item_id).first()\n    if not item:\n        raise HTTPException(status_code=404, detail=\"Author not found\")\n    return item", "category": "query_optimization", "subcategory": "joinedload", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_121 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_121: List[WebSocket] = []\n\n@app.websocket(\"/ws_121/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_121.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_121:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_121.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_1 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_1: List[WebSocket] = []\n\n@app.websocket(\"/ws_1/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_1.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_1:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_1.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_44 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_44: List[WebSocket] = []\n\n@app.websocket(\"/ws_44/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_44.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_44:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_44.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_29 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_29: List[WebSocket] = []\n\n@app.websocket(\"/ws_29/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_29.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_29:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_29.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_46 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_46: List[WebSocket] = []\n\n@app.websocket(\"/ws_46/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_46.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_46:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_46.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_99 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_99: List[WebSocket] = []\n\n@app.websocket(\"/ws_99/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_99.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_99:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_99.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_98 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_98: List[WebSocket] = []\n\n@app.websocket(\"/ws_98/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_98.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_98:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_98.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_72 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_72: List[WebSocket] = []\n\n@app.websocket(\"/ws_72/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_72.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_72:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_72.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_41 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_41: List[WebSocket] = []\n\n@app.websocket(\"/ws_41/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_41.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_41:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_41.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_97 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_97: List[WebSocket] = []\n\n@app.websocket(\"/ws_97/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_97.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_97:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_97.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_122 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_122: List[WebSocket] = []\n\n@app.websocket(\"/ws_122/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_122.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_122:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_122.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_139 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_139: List[WebSocket] = []\n\n@app.websocket(\"/ws_139/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_139.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_139:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_139.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_28 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_28: List[WebSocket] = []\n\n@app.websocket(\"/ws_28/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_28.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_28:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_28.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_118 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_118: List[WebSocket] = []\n\n@app.websocket(\"/ws_118/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_118.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_118:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_118.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_148 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_148: List[WebSocket] = []\n\n@app.websocket(\"/ws_148/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_148.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_148:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_148.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_103 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_103: List[WebSocket] = []\n\n@app.websocket(\"/ws_103/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_103.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_103:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_103.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_126 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_126: List[WebSocket] = []\n\n@app.websocket(\"/ws_126/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_126.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_126:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_126.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_51 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_51: List[WebSocket] = []\n\n@app.websocket(\"/ws_51/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_51.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_51:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_51.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_124 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_124: List[WebSocket] = []\n\n@app.websocket(\"/ws_124/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_124.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_124:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_124.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_20 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_20: List[WebSocket] = []\n\n@app.websocket(\"/ws_20/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_20.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_20:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_20.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_84 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_84: List[WebSocket] = []\n\n@app.websocket(\"/ws_84/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_84.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_84:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_84.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_3 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_3: List[WebSocket] = []\n\n@app.websocket(\"/ws_3/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_3.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_3:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_3.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_43 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_43: List[WebSocket] = []\n\n@app.websocket(\"/ws_43/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_43.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_43:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_43.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_4 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_4: List[WebSocket] = []\n\n@app.websocket(\"/ws_4/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_4.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_4:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_4.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_35 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_35: List[WebSocket] = []\n\n@app.websocket(\"/ws_35/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_35.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_35:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_35.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_2 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_2: List[WebSocket] = []\n\n@app.websocket(\"/ws_2/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_2.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_2:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_2.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_14 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_14: List[WebSocket] = []\n\n@app.websocket(\"/ws_14/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_14.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_14:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_14.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_59 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_59: List[WebSocket] = []\n\n@app.websocket(\"/ws_59/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_59.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_59:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_59.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_80 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_80: List[WebSocket] = []\n\n@app.websocket(\"/ws_80/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_80.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_80:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_80.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_76 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_76: List[WebSocket] = []\n\n@app.websocket(\"/ws_76/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_76.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_76:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_76.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_108 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_108: List[WebSocket] = []\n\n@app.websocket(\"/ws_108/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_108.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_108:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_108.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_134 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_134: List[WebSocket] = []\n\n@app.websocket(\"/ws_134/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_134.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_134:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_134.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_145 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_145: List[WebSocket] = []\n\n@app.websocket(\"/ws_145/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_145.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_145:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_145.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_65 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_65: List[WebSocket] = []\n\n@app.websocket(\"/ws_65/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_65.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_65:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_65.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_83 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_83: List[WebSocket] = []\n\n@app.websocket(\"/ws_83/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_83.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_83:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_83.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_100 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_100: List[WebSocket] = []\n\n@app.websocket(\"/ws_100/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_100.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_100:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_100.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_9 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_9: List[WebSocket] = []\n\n@app.websocket(\"/ws_9/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_9.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_9:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_9.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_137 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_137: List[WebSocket] = []\n\n@app.websocket(\"/ws_137/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_137.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_137:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_137.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_8 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_8: List[WebSocket] = []\n\n@app.websocket(\"/ws_8/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_8.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_8:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_8.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_11 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_11: List[WebSocket] = []\n\n@app.websocket(\"/ws_11/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_11.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_11:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_11.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_37 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_37: List[WebSocket] = []\n\n@app.websocket(\"/ws_37/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_37.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_37:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_37.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_78 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_78: List[WebSocket] = []\n\n@app.websocket(\"/ws_78/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_78.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_78:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_78.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_60 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_60: List[WebSocket] = []\n\n@app.websocket(\"/ws_60/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_60.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_60:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_60.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_144 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_144: List[WebSocket] = []\n\n@app.websocket(\"/ws_144/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_144.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_144:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_144.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_120 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_120: List[WebSocket] = []\n\n@app.websocket(\"/ws_120/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_120.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_120:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_120.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_123 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_123: List[WebSocket] = []\n\n@app.websocket(\"/ws_123/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_123.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_123:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_123.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_77 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_77: List[WebSocket] = []\n\n@app.websocket(\"/ws_77/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_77.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_77:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_77.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_12 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_12: List[WebSocket] = []\n\n@app.websocket(\"/ws_12/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_12.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_12:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_12.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_63 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_63: List[WebSocket] = []\n\n@app.websocket(\"/ws_63/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_63.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_63:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_63.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_104 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_104: List[WebSocket] = []\n\n@app.websocket(\"/ws_104/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_104.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_104:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_104.remove(websocket)", "category": "websockets"}
{"instruction": "Create a FastAPI application with WebSocket support. Include real-time chat, notifications, and bidirectional communication.", "input": "", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\nimport json\n\napp = FastAPI()\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/chat\")\nasync def websocket_chat(websocket: WebSocket):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            message = json.loads(data)\n            response = {\n                \"username\": message.get(\"username\", \"Anonymous\"),\n                \"message\": message.get(\"message\", \"\"),\n                \"timestamp\": \"2025-01-01T00:00:00\"\n            }\n            await manager.broadcast(json.dumps(response))\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(json.dumps({\"message\": \"User disconnected\"}))\n\n@app.websocket(\"/ws/notifications\")\nasync def websocket_notifications(websocket: WebSocket):\n    await websocket.accept()\n    try:\n        while True:\n            data = await websocket.receive_text()\n            notification = {\"type\": \"notification\", \"data\": data}\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        pass\n\n@app.get(\"/\")\ndef home():\n    return {\"message\": \"WebSocket server running\"}", "source_phase": "phase2_advanced", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_114 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_114: List[WebSocket] = []\n\n@app.websocket(\"/ws_114/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_114.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_114:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_114.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_88 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_88: List[WebSocket] = []\n\n@app.websocket(\"/ws_88/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_88.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_88:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_88.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_36 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_36: List[WebSocket] = []\n\n@app.websocket(\"/ws_36/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_36.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_36:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_36.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_141 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_141: List[WebSocket] = []\n\n@app.websocket(\"/ws_141/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_141.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_141:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_141.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_33 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_33: List[WebSocket] = []\n\n@app.websocket(\"/ws_33/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_33.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_33:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_33.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_105 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_105: List[WebSocket] = []\n\n@app.websocket(\"/ws_105/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_105.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_105:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_105.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_31 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_31: List[WebSocket] = []\n\n@app.websocket(\"/ws_31/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_31.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_31:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_31.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_47 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_47: List[WebSocket] = []\n\n@app.websocket(\"/ws_47/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_47.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_47:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_47.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_130 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_130: List[WebSocket] = []\n\n@app.websocket(\"/ws_130/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_130.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_130:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_130.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_75 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_75: List[WebSocket] = []\n\n@app.websocket(\"/ws_75/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_75.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_75:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_75.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_129 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_129: List[WebSocket] = []\n\n@app.websocket(\"/ws_129/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_129.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_129:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_129.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_18 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_18: List[WebSocket] = []\n\n@app.websocket(\"/ws_18/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_18.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_18:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_18.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_132 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_132: List[WebSocket] = []\n\n@app.websocket(\"/ws_132/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_132.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_132:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_132.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_64 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_64: List[WebSocket] = []\n\n@app.websocket(\"/ws_64/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_64.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_64:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_64.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_109 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_109: List[WebSocket] = []\n\n@app.websocket(\"/ws_109/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_109.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_109:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_109.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_45 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_45: List[WebSocket] = []\n\n@app.websocket(\"/ws_45/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_45.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_45:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_45.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_50 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_50: List[WebSocket] = []\n\n@app.websocket(\"/ws_50/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_50.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_50:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_50.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_102 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_102: List[WebSocket] = []\n\n@app.websocket(\"/ws_102/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_102.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_102:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_102.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_53 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_53: List[WebSocket] = []\n\n@app.websocket(\"/ws_53/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_53.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_53:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_53.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_110 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_110: List[WebSocket] = []\n\n@app.websocket(\"/ws_110/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_110.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_110:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_110.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_127 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_127: List[WebSocket] = []\n\n@app.websocket(\"/ws_127/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_127.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_127:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_127.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_94 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_94: List[WebSocket] = []\n\n@app.websocket(\"/ws_94/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_94.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_94:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_94.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_32 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_32: List[WebSocket] = []\n\n@app.websocket(\"/ws_32/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_32.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_32:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_32.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_131 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_131: List[WebSocket] = []\n\n@app.websocket(\"/ws_131/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_131.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_131:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_131.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_81 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_81: List[WebSocket] = []\n\n@app.websocket(\"/ws_81/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_81.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_81:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_81.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_112 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_112: List[WebSocket] = []\n\n@app.websocket(\"/ws_112/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_112.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_112:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_112.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_62 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_62: List[WebSocket] = []\n\n@app.websocket(\"/ws_62/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_62.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_62:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_62.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_133 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_133: List[WebSocket] = []\n\n@app.websocket(\"/ws_133/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_133.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_133:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_133.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_125 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_125: List[WebSocket] = []\n\n@app.websocket(\"/ws_125/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_125.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_125:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_125.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_111 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_111: List[WebSocket] = []\n\n@app.websocket(\"/ws_111/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_111.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_111:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_111.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_71 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_71: List[WebSocket] = []\n\n@app.websocket(\"/ws_71/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_71.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_71:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_71.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_119 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_119: List[WebSocket] = []\n\n@app.websocket(\"/ws_119/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_119.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_119:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_119.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_26 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_26: List[WebSocket] = []\n\n@app.websocket(\"/ws_26/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_26.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_26:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_26.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_15 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_15: List[WebSocket] = []\n\n@app.websocket(\"/ws_15/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_15.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_15:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_15.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_143 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_143: List[WebSocket] = []\n\n@app.websocket(\"/ws_143/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_143.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_143:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_143.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_101 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_101: List[WebSocket] = []\n\n@app.websocket(\"/ws_101/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_101.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_101:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_101.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_79 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_79: List[WebSocket] = []\n\n@app.websocket(\"/ws_79/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_79.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_79:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_79.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_13 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_13: List[WebSocket] = []\n\n@app.websocket(\"/ws_13/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_13.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_13:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_13.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_82 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_82: List[WebSocket] = []\n\n@app.websocket(\"/ws_82/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_82.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_82:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_82.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_68 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_68: List[WebSocket] = []\n\n@app.websocket(\"/ws_68/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_68.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_68:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_68.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_117 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_117: List[WebSocket] = []\n\n@app.websocket(\"/ws_117/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_117.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_117:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_117.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_147 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_147: List[WebSocket] = []\n\n@app.websocket(\"/ws_147/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_147.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_147:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_147.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_135 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_135: List[WebSocket] = []\n\n@app.websocket(\"/ws_135/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_135.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_135:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_135.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_42 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_42: List[WebSocket] = []\n\n@app.websocket(\"/ws_42/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_42.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_42:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_42.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_17 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_17: List[WebSocket] = []\n\n@app.websocket(\"/ws_17/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_17.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_17:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_17.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_67 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_67: List[WebSocket] = []\n\n@app.websocket(\"/ws_67/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_67.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_67:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_67.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_52 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_52: List[WebSocket] = []\n\n@app.websocket(\"/ws_52/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_52.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_52:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_52.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_89 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_89: List[WebSocket] = []\n\n@app.websocket(\"/ws_89/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_89.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_89:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_89.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_93 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_93: List[WebSocket] = []\n\n@app.websocket(\"/ws_93/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_93.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_93:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_93.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_40 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_40: List[WebSocket] = []\n\n@app.websocket(\"/ws_40/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_40.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_40:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_40.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_92 and pattern_2", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_92: List[WebSocket] = []\n\n@app.websocket(\"/ws_92/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_92.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_92:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_92.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_115 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_115: List[WebSocket] = []\n\n@app.websocket(\"/ws_115/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_115.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_115:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_115.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_24 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_24: List[WebSocket] = []\n\n@app.websocket(\"/ws_24/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_24.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_24:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_24.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time notifications with authentication.", "output": "from fastapi import WebSocket, Depends, HTTPException\nfrom jose import JWTError, jwt\n\nasync def get_current_user_ws(websocket: WebSocket, token: str):\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        return payload.get(\"sub\")\n    except JWTError:\n        await websocket.close(code=1008)\n        return None\n\n@app.websocket(\"/ws/notifications\")\nasync def notifications_endpoint(websocket: WebSocket, token: str):\n    user = await get_current_user_ws(websocket, token)\n    if not user:\n        return\n    \n    await websocket.accept()\n    try:\n        while True:\n            # Send notifications to user\n            notification = await get_user_notification(user)\n            await websocket.send_json(notification)\n    except WebSocketDisconnect:\n        print(f\"User {user} disconnected\")", "category": "websockets", "subcategory": "notifications", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_73 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_73: List[WebSocket] = []\n\n@app.websocket(\"/ws_73/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_73.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_73:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_73.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_57 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_57: List[WebSocket] = []\n\n@app.websocket(\"/ws_57/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_57.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_57:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_57.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_16 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_16: List[WebSocket] = []\n\n@app.websocket(\"/ws_16/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_16.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_16:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_16.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_48 and pattern_8", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_48: List[WebSocket] = []\n\n@app.websocket(\"/ws_48/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_48.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_48:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_48.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_146 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_146: List[WebSocket] = []\n\n@app.websocket(\"/ws_146/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_146.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_146:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_146.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_91 and pattern_1", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_91: List[WebSocket] = []\n\n@app.websocket(\"/ws_91/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_91.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_91:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_91.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_74 and pattern_4", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_74: List[WebSocket] = []\n\n@app.websocket(\"/ws_74/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_74.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_74:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_74.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_140 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_140: List[WebSocket] = []\n\n@app.websocket(\"/ws_140/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_140.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_140:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_140.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_19 and pattern_9", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_19: List[WebSocket] = []\n\n@app.websocket(\"/ws_19/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_19.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_19:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_19.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_95 and pattern_5", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_95: List[WebSocket] = []\n\n@app.websocket(\"/ws_95/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_95.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_95:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_95.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_30 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_30: List[WebSocket] = []\n\n@app.websocket(\"/ws_30/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_30.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_30:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_30.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_136 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_136: List[WebSocket] = []\n\n@app.websocket(\"/ws_136/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_136.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_136:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_136.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_116 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_116: List[WebSocket] = []\n\n@app.websocket(\"/ws_116/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_116.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_116:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_116.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_10 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_10: List[WebSocket] = []\n\n@app.websocket(\"/ws_10/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_10.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_10:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_10.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_66 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_66: List[WebSocket] = []\n\n@app.websocket(\"/ws_66/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_66.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_66:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_66.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
{"instruction": "Implement FastAPI websockets with feature_87 and pattern_7", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_87: List[WebSocket] = []\n\n@app.websocket(\"/ws_87/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_87.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_87:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_87.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_90 and pattern_0", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_90: List[WebSocket] = []\n\n@app.websocket(\"/ws_90/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_90.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_90:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_90.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_23 and pattern_3", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_23: List[WebSocket] = []\n\n@app.websocket(\"/ws_23/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_23.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_23:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_23.remove(websocket)", "category": "websockets"}
{"instruction": "Implement FastAPI websockets with feature_96 and pattern_6", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\napp = FastAPI()\nactive_connections_96: List[WebSocket] = []\n\n@app.websocket(\"/ws_96/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: str):\n    await websocket.accept()\n    active_connections_96.append(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            for connection in active_connections_96:\n                await connection.send_text(f\"Client {client_id}: {data}\")\n    except WebSocketDisconnect:\n        active_connections_96.remove(websocket)", "category": "websockets"}
{"instruction": "Create a WebSocket endpoint for real-time chat with connection management.", "output": "from fastapi import FastAPI, WebSocket, WebSocketDisconnect\nfrom typing import List\n\nclass ConnectionManager:\n    def __init__(self):\n        self.active_connections: List[WebSocket] = []\n    \n    async def connect(self, websocket: WebSocket):\n        await websocket.accept()\n        self.active_connections.append(websocket)\n    \n    def disconnect(self, websocket: WebSocket):\n        self.active_connections.remove(websocket)\n    \n    async def broadcast(self, message: str):\n        for connection in self.active_connections:\n            await connection.send_text(message)\n\nmanager = ConnectionManager()\n\n@app.websocket(\"/ws/{client_id}\")\nasync def websocket_endpoint(websocket: WebSocket, client_id: int):\n    await manager.connect(websocket)\n    try:\n        while True:\n            data = await websocket.receive_text()\n            await manager.broadcast(f\"Client #{client_id}: {data}\")\n    except WebSocketDisconnect:\n        manager.disconnect(websocket)\n        await manager.broadcast(f\"Client #{client_id} left\")", "category": "websockets", "subcategory": "chat", "difficulty": "advanced", "source": "v5_7_realistic"}
